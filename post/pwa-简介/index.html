<!DOCTYPE html>
<html lang="zh-cn" data-theme="light"><head>
    <meta name="google-site-verification" content="kw1N-Xm6qEr1c9PGuRd0U_T6DXkw_EHsLyz5LpuDDv8" />
    <meta name="msvalidate.01" content="EE98205D30806C22C519683EFC53E9BA" />
    <meta name="baidu-site-verification" content="iPC3wUcQLL" />
    <title>  PWA 详解 </title>
    <meta charset="utf-8" /><meta name="generator" content="Hugo 0.74.3" /><meta name="viewport" content="width=device-width,initial-scale=1, minimum-scale=1, maximum-scale=1" />
    <meta name="description" itemprop="description"
        content=" PWA 详解 " />
    <meta name="keywords" itemprop="keywords"
        content=" [PWA] " />
    <base href="https://tomtomyoung.top/">

    
    <link rel="shortcut icon" href="https://tomtomyoung.top/favicons//favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tomtomyoung.top/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tomtomyoung.top/favicons/favicon-16x16.png">
    <link rel="mask-icon" href="https://tomtomyoung.top/favicons/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="apple-touch-icon" sizes="180x180" href="https://tomtomyoung.top/favicons/apple-touch-icon.png">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="msapplication-TileImage" content="https://tomtomyoung.top/favicons/mstile-144x144.png">
    <link rel="manifest" href="https://tomtomyoung.top/manifest.json">

    <link rel="canonical" href="https://tomtomyoung.top/post/pwa-%E7%AE%80%E4%BB%8B/">
    <link rel="stylesheet" type="text/css" href="https://at.alicdn.com/t/font_2450869_iypnqhtzjei.css">
    
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="https://tomtomyoung.top/css/style.min.css" integrity="" type="text/css">
    
    
    <script type="text/javascript" src="https://tomtomyoung.top/js/docsearch.min.js" integrity=""></script>
</head><body class="animated fadeInDown">
<div class="main"><div class="percentage_container">
    <div class="percentage" id="percentage"></div>
</div><div class="toc sub-container">
    <div class="toc-header">
        <span>目录</span>
    </div><ul class="toc-h2"><li>
                <span class="toc-link">1. 什么是 PWA?</span>
            </li>
            <li>
                <span class="toc-link">2. WEB 应用的历史</span>
            </li>
            <li>
                <span class="toc-link">3. PWA 的特性</span>
            </li>
            
                    <ul class="toc-h3"><li>
                <span class="toc-link">1. 可发现</span>
            </li>
            <li>
                <span class="toc-link">2. 可安装</span>
            </li>
            <li>
                <span class="toc-link">3. 可链接</span>
            </li>
            <li>
                <span class="toc-link">4. 独立于网络</span>
            </li>
            <li>
                <span class="toc-link">5. 渐进式</span>
            </li>
            <li>
                <span class="toc-link">6. 可推送</span>
            </li>
            <li>
                <span class="toc-link">7. 响应式</span>
            </li>
            <li>
                <span class="toc-link">8. 安全</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">4. 实现 PWA 所需的技术</span>
            </li>
            
                    <ul class="toc-h3"><li>
                <span class="toc-link">1. Service Worker</span>
            </li>
            <li>
                <span class="toc-link">2. Cache API</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">4. 技术之外的 PWA 的意义</span>
            </li>
            <li>
                <span class="toc-link">5. PWA 的地域性</span>
            </li>
            <li>
                <span class="toc-link">6. PWA 和微信小程序</span>
            </li>
            </div><div class="single-post container">
    <div class="post">
      <div class="header">
        <span class="title">PWA 详解</span>
        
        <div class="info">
          <span>📅 2021-12-22</span>
          <span>👦 Tomtom Young</span>
          <span>📖 4021字</span>
          <span>⏱ 9分钟</span>
        </div>
        
      </div>
      <div class="content markdown-body">
        <blockquote>
<p>参考：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps">MDN_渐进式 Web 应用（PWA）</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1567825">小程序的老祖宗PWA为什么没有火起来？</a></p>
<p><a href="https://maxket.com/wechat-mini-program-vs-pwa/">被微信小程序山寨的PWA到底是什么鬼？</a></p>
<p><a href="https://web.dev/learn/pwa/">web.dev_Learn PWA!</a></p>
<p><a href="https://www.zhihu.com/question/20628050">Responsive design 和 Adaptive design 的区别？</a></p>
<p><a href="https://www.leiphone.com/category/zhuanlan/UEiart497WUzS62u.html">我们真的需要网页版App吗？Google PWA的困局</a></p>
<p><a href="https://developers.google.com/web/fundamentals?hl=zh-cn">Web Fundamentals</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">MDN_Cache</a></p>
</blockquote>
<h2 id="1-什么是-pwa">1. 什么是 PWA?</h2>
<blockquote>
<p>PWA（Progressive Web Apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。</p>
</blockquote>
<p>PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。</p>
<h2 id="2-web-应用的历史">2. WEB 应用的历史</h2>
<ul>
<li>
<p>大约在 2005 年，整个 Web 在一些新技术如 .NET ， PHP ， Ajax 的推动下由静态向动态过渡。</p>
</li>
<li>
<p>2007 年原生 Native App 开始兴起。</p>
</li>
<li>
<p>在 2010 年中，HTML5，CSS3，和 JavaScript 开始推动 Web 向更好的用户体验迈进，其中 <a href="https://maxket.com/responsive-vs-adaptive-web-design/">Responsive Web Design</a> 也就是我们俗称的响应式设计开始挑战原生的 App。但是 RWD 失败了，究其原因是 RWD 在用户体验上仍然和原生的 App 那样预载入大量的框架界面的方案在用户体验和性能上有很大差距。</p>
<p><img src="https://pic3.zhimg.com/80/286aebd96cb9d6ccc98ae8d26c30f56e_720w.jpg?source=1940ef5c" alt="img"></p>
</li>
<li>
<p>期间阵亡的还有许多其他的解决方案，比如 Adobe AIR Applications，Chrome Packaged Applications 等。品牌为了占据用户智能设备上的一个144×144的空间费尽了力气。</p>
</li>
<li>
<p>这些受人诟病的问题最终被 PWA 解决了，而且解决得非常彻底。它是2015年6月14日由设计师 Frances Berriman 和 Chrome 工程师 Alex Russell 在一顿晚餐中一拍即合提出的概念。PWA的提出标志着移动互联网进入了下一世代。</p>
</li>
</ul>
<h2 id="3-pwa-的特性">3. PWA 的特性</h2>
<p><img src="https://img-blog.csdnimg.cn/20190710133242733.gif" alt="img-1"></p>
<blockquote>
<p>PWA 不是只使用一种技术创建的。它代表了构建 Web 应用程序的新理念，涉及一些特定的模式，API 和其他功能。一眼是看不出来一个 Web App 是不是 PWA 的。如果应用程序满足某些要求，或者实现了一组特定的功能，我们就可以将其视为 PWA。</p>
</blockquote>
<p>辨别一个 Web 应用是否是 PWA 有一些关键原则。一个 PWA 应该具有以下特点：</p>
<h3 id="1--可发现">1.  可发现</h3>
<p>可以通过搜索引擎发现。</p>
<h3 id="2--可安装">2.  可安装</h3>
<p>应用可被添加到自主屏，全屏运行。</p>
<h3 id="3--可链接">3.  可链接</h3>
<p>可以简单地通过 URL 分享应用。</p>
<h3 id="4--独立于网络">4.  独立于网络</h3>
<p>就是离线和弱网环境也能秒开应用。Hybrid 架构搞了那么久，说白了不就为的这个吗？</p>
<p>之前有个东西叫 Application Cache，但是并不成功。</p>
<p>Chrome 搞了 Service Worker 出来，给了 Web 一个可以跑在后台的线程，它可以搭配 Cache API 做缓存、可以拦截所有 HTTP 请求并使用 Fetch API 进行 response ，一个非常完备的 Proxy 就这么诞生了。</p>
<p><img src="https://static.leiphone.com/uploads/new/article/740_740/201606/5757e8f2babb0.png?imageMogr2/quality/90" alt="我们真的需要网页版App吗？Google PWA的困局"></p>
<h3 id="5--渐进式">5.  渐进式</h3>
<p>应用的功能是渐进的，在新版本的浏览器上可以使用全部功能，在一些不支持新特性的老版本浏览器仍旧可以使用其中的部分功能。</p>
<h3 id="6--可推送">6.  可推送</h3>
<p>无论何时有新的内容，都可以发送通知，推送通知依赖 Service Worker 与 HTTP Push，不过默认支持的是 GCM（Google Cloud Messaging），对国内开发者不友好。</p>
<h3 id="7--响应式">7.  响应式</h3>
<p>不管是什么浏览器分辨率，不管是在桌面上、平板电脑上还是手机上，PWA应用 都可以达到最佳浏览效果。</p>
<h3 id="8--安全">8.  安全</h3>
<p>在用户、应用和服务器之间的连接是安全的，第三方无法访问你的敏感数据，HTTPS加密。</p>
<h2 id="4-实现-pwa-所需的技术">4. 实现 PWA 所需的技术</h2>
<ul>
<li>Web App Manifest 应用加壳</li>
<li>Service Worker 服务线程</li>
<li>Cache API 缓存</li>
<li>Push、Notification 推送与通知</li>
<li>Background Sync 后台同步</li>
<li>Responsive Web Design 响应式设计</li>
</ul>
<h3 id="1--service-worker">1.  Service Worker</h3>
<p><img src="http://i2.kknews.cc/QQ9GpXI-1XcwsjDC-98jH_4ZqdqB8vD-QQ/0.jpg" alt="img"></p>
<blockquote>
<p>Service Worker 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门。</p>
<p>现在，已包括如 推送通知 和 后台同步 等功能。 将来，Service Worker 将会支持如定期同步或地理围栏等其他功能。</p>
</blockquote>
<p>Service Worker 相关注意事项：</p>
<ul>
<li>它是一种 JavaScript Worker，无法直接访问 DOM。 Service Worker 通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。</li>
<li>Service Worker 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。</li>
<li>Service Worker 在不用时会被中止，并在下次有需要时重启，因此，您不能依赖 Service Worker <code>onfetch</code> 和 <code>onmessage</code> 处理程序中的全局状态。 如果存在您需要持续保存并在重启后加以重用的信息，Service Worker 可以访问 IndexedDB API。</li>
<li>Service Worker 广泛地利用了 promise。</li>
</ul>
<h3 id="2-cache-api">2. Cache API</h3>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/match"><code>Cache.match(request, options)</code></a></p>
<p>返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>对象，resolve的结果是跟 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a> 对象匹配的第一个已经缓存的请求。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/matchAll"><code>Cache.matchAll(request, options)</code></a></p>
<p>返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 对象，resolve的结果是跟<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a>对象匹配的所有请求组成的数组。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/add"><code>Cache.add(request)</code></a></p>
<p>抓取这个URL, 检索并把返回的response对象添加到给定的Cache对象.这在功能上等同于调用 fetch(), 然后使用 Cache.put() 将response添加到cache中.</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/addAll"><code>Cache.addAll(requests)</code></a></p>
<p>抓取一个URL数组，检索并把返回的response对象添加到给定的Cache对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/put"><code>Cache.put(request, response)</code></a></p>
<p>同时抓取一个请求及其响应，并将其添加到给定的cache。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/delete"><code>Cache.delete(request, options)</code></a></p>
<p>搜索key值为request的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a> 条目。如果找到，则删除该<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a> 条目，并且返回一个resolve为true的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>对象；如果未找到，则返回一个resolve为false的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/keys"><code>Cache.keys(request, options)</code></a></p>
<p>返回一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>对象，resolve的结果是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache"><code>Cache</code></a>对象key值组成的数组。</p>
</blockquote>
<h2 id="4-技术之外的-pwa-的意义">4. 技术之外的 PWA 的意义</h2>
<p>PWA看上去并不是那么 breakthrough ，但这可能只是站在开发者的角度之上的。</p>
<p>大家都很熟悉 Ajax 这个说法，它出现于2005年，用于描述 Gmail (2004) 或者 Google Maps (2005) 这样的网页应用，这个词不但宣告了 Web 客户端技术的全面复兴与流行，也成为了 Web 2.0 的最大技术推动。然而事实是，早在 Ajax 这个词出现的5年前，IE5已经广泛支持了 XML HTTP Request 并实现了Outlook Web App (2000) 。</p>
<p>技术并不是不需要包装。如果没有“ H5 ”这样易于传播的烂词， Mobile Web 乃至前端工程师在所有中国群众、新手开发者、产品经理、创业者中也不会得到如此重视。</p>
<p>身为开发者我们知道，Web 这几年发展迅猛，我们能做的事情越来越多。但是在大量群众的心里可能并不是这样，如果你做出一个体验足够优秀的 Web 产品，可能大家的第一反应是：“这肯定是一个 App”。</p>
<p>而这正是 PWA 希望解决的问题，Chrome 团队希望用一个新的 buzzword（流行词）来影响、改变用户的期待。作为开发者我们知道，PWA 归根结底还是个网页，当然，是个更好的网页。但是 Chrome 希望让用户感受到不一样：“哦这是个普通网页；哦这个 Chrome 告诉我可以添加到主屏幕上，告诉我可以离线、可以推送、这是个 PWA”</p>
<p>这也是为什么 Rahul 一直在强调 Mobile Web 已经 Business ready，并积极与企业合作去推出 PWA 的原因，Chrome 团队希望用实际的产品要告诉用户，PWA 就是那个体验跟 App 一样好但是都不用你安装的网页应用。”</p>
<p>Google 大力鼓吹的印度第一电商 FlipKart 也很有意思，他们把自己的官网改为了 PWA，命名为 FlipKart Lite，然后还拍了宣传片兼教程来公开介绍这种新体验以及新技术。</p>
<p><img src="https://static.leiphone.com/uploads/new/article/740_740/201606/5757e8f854949.png?imageMogr2/quality/90" alt="我们真的需要网页版App吗？Google PWA的困局"></p>
<p>推动一个技术的发展其实是很多维度的，你要吸引的不止是开发者、还有用户和公司（让它们使用这个技术）、最终才能让整个生态建立起来。所以无论 App Store 还是 Google Play 总是要说我们帮助了多少公司/开发者获得了成功，就是这个道理。</p>
<p>从这个角度来说，PWA 可能比单纯的技术突破对 Mobile Web 整个生态的影响要更大。开发者之间希望说服对方一个技术比另一个技术更好都是一件很难的事情，更不要说说服用户了。我们不能说 PWA 完全是个营销词汇，但我真心希望这轮对用户的营销能够成功，让用户对 Mobile Web 有所改观，这才能真正解决我上面提到的“用户习惯难以养成”的问题。</p>
<h2 id="5-pwa-的地域性">5. PWA 的地域性</h2>
<p>一个很有意思的现象是：“Apple 亲中，Google 亲印”，不止是管理层的组成问题，而是对市场环境的优胜劣汰。</p>
<p>Google 的技术在国内推进本身就是很痛苦的，Android 摇身一变”安卓”得以在国内驰骋，但 PWA 在中国的发展则困难重重：</p>
<blockquote>
<p>国内 iPhone 居多，首先就不支持 PWA。</p>
<p>各路 Android ROM 中的浏览器早都已经被改的没有人形了，大家在支持 PWA 这件事情上肯定毫无兴趣 ——什么添加主屏，与我的利益毫不相关啊。</p>
<p>原生 Chrome 虽然在国内桌面端的市占率还不错，但是移动端应该差到不行。</p>
<p>依赖 GCM 的通知推送，直接再见。</p>
<p>国内的 Web 环境非常复杂、首先是各种 Webview，然后才轮得到浏览器。</p>
<p>国内的互联网公司大都“技术深厚”，各种黑科技大行其道，哪里轮得到 PWA。</p>
</blockquote>
<p>在印度，PWA 简直就是神器：</p>
<blockquote>
<p>由于都是 Google 服务健全的 Android 设备，标配 Chrome，PWA 一推，用户到达率简直直逼100%。</p>
<p>印度网差，下载一个 App 痛苦，一个可以“流式下载”的 PWA 在用户初次访问上就可以完爆 Native App。</p>
<p>互联网环境还比较原始，大都直接亲 Google，公司支持率也会非常高。</p>
</blockquote>
<h2 id="6-pwa-和微信小程序">6. PWA 和微信小程序</h2>
<p>微信小程序的定位是：</p>
<blockquote>
<p>小程序是一个不需要下载安装就可使用的应用，它实现了应用触手可及的梦想，用户扫一扫或者搜一下即可打开应用。也体现了用完即走的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。从字面上看小程序具有类似Web应用的热部署能力，在功能上又接近于原生APP。</p>
</blockquote>
<p>微信小程序的构建逻辑：</p>
<blockquote>
<p>小程序采用 Web-Native 混合方案。WebView 渲染基本网页内容，部分块级元素如地图、视频、底部导航栏等由 Native View 渲染。在Android开发者模式中打开显示布局边界选项，可以在小程序中看到所有的Native View被框线分割，而显示主体内容是一块完整的WebView。</p>
</blockquote>
<p>微信小程序的双线程模型：</p>
<blockquote>
<p>与传统的浏览器 Web 页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JS Core 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JS Brigde 做中转。</p>
</blockquote>
<p>微信小程序更新视图的流程是：</p>
<blockquote>
<p>每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下：</p>
<ol>
<li>小程序逻辑层调用宿主环境的 setData 方法。</li>
<li>逻辑层执行 JSON.stringify 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过 evaluateJavascript 执行脚本将数据传输到渲染层。</li>
<li>渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。</li>
<li>WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在 WXML 片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到 UI 视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。</li>
</ol>
</blockquote>

      </div>
      <div class="footer">
        <span><a class="category" href="https://tomtomyoung.top/categories/%E5%89%8D%E7%AB%AF/">前端</a></span>
        <span><a class="tag" href="https://tomtomyoung.top/tags/pwa/">PWA</a></span>
      </div>
    </div>

    <ul class="menu">
    <li class="menu-item">
        <i class="iconfont icon-top item-btn" id="back_top_btn"></i>
    </li>
    <li class="menu-item">
        <a href="https://tomtomyoung.top/" id="back-btn">
            <i class="iconfont icon-home item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <i class="iconfont icon-switch item-btn" id="switch_btn"></i>
    </li>
    <li class="menu-item">
        <i class="iconfont icon-search item-btn" id="search_btn"></i>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://tomtomyoung.top/post/vue-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" data-tooltip="vue 单元测试">
            <i class="iconfont icon-left item-btn"></i>
            
        </a>
    </li>
    <li class="menu-item">
        
        </a>
    </li>
</ul>

  </div>
</div>

<div class="cover" id="cover">
        <div class="search-container">
    <input type="search" class="docsearch-input search-input" placeholder="搜索关键词" />
    
</div>
    </div>
</body>






<script type="text/javascript" src="https://tomtomyoung.top/js/util.min.js" integrity=""></script>
<script>
    if ('serviceWorker' in navigator) {
        const PREFETCH = true;
        const PREFETCH_LINK_RELS = ['index', 'next', 'prev', 'prefetch'];
        function prefetchCache() {
            if (navigator.serviceWorker.controller) {
                let links = document.querySelectorAll(
                    PREFETCH_LINK_RELS.map((rel) => {
                        return 'link[rel=' + rel + ']';
                    }).join(',')
                );
                if (links.length > 0) {
                    Array.from(links)
                        .map((link) => {
                            let href = link.getAttribute('href');
                            navigator.serviceWorker.controller.postMessage({
                                action: 'cache',
                                url: href,
                            });
                        });
                }
            }
        }

        navigator.serviceWorker
            .register('/sw.js', { scope: '/' })
            .then(() => {
                console.log('Service Worker Registered');
            });

        navigator.serviceWorker
            .ready
            .then(() => {
                if (PREFETCH) {
                    console.log('Service Worker Ready');
                    prefetchCache();
                }
            });
    }
</script></html>