<!DOCTYPE html>
<html lang="zh-cn" data-theme="light"><head>
    <meta name="google-site-verification" content="kw1N-Xm6qEr1c9PGuRd0U_T6DXkw_EHsLyz5LpuDDv8" />
    <meta name="msvalidate.01" content="EE98205D30806C22C519683EFC53E9BA" />
    <meta name="baidu-site-verification" content="iPC3wUcQLL" />
    <title>  面试题——计算机网络 </title>
    <meta charset="utf-8" /><meta name="generator" content="Hugo 0.85.0" /><meta name="viewport" content="width=device-width,initial-scale=1, minimum-scale=1, maximum-scale=1" />
    <meta name="description" itemprop="description"
        content=" 面试题——计算机网络 " />
    <meta name="keywords" itemprop="keywords"
        content=" [面试题 计算机网络] " />
    <base href="https://tomtomyoung.top/">
    <link rel="shortcut icon" href="https://tomtomyoung.top/favicons//favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tomtomyoung.top/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tomtomyoung.top/favicons/favicon-16x16.png">
    <link rel="canonical" href="https://tomtomyoung.top/post/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
    <link rel="stylesheet" type="text/css" href="https://at.alicdn.com/t/font_2450869_iypnqhtzjei.css">
    
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="https://tomtomyoung.top/css/style.min.fbc330e5c2ec7c06a2f4fa6c1ead9ab7ad891862eaedb9e331d7fd9a6e4000ae.css" integrity="" type="text/css">
    
    
    <script type="text/javascript" src="https://tomtomyoung.top/js/docsearch.min.d5ae28a04c0ed8fe05c1dcff4e6a45bbbe67882cbf8550b45fb8d8d9dbb6f6dbf7c476b926c955a06e54d94959c1571c60ac9abdcdb386615ac5b445241be88d.js" integrity=""></script>
</head><body class="animated fadeInDown">
<div class="main"><div class="percentage_container">
    <div class="percentage" id="percentage"></div>
</div><div class="toc sub-container">
    <div class="toc-header">
        <span>目录</span>
    </div><ul class="toc-h3"><li>
                <span class="toc-link">1. 七层模型和五层模型</span>
            </li>
            
                    <ul class="toc-h4"><li>
                <span class="toc-link">1.1 七层模型与五层模型的介绍</span>
            </li>
            <li>
                <span class="toc-link">1.2 五层模型各层的作用和协议</span>
            </li>
            <li>
                <span class="toc-link">1.3 七层模型中会话层和表示层的作用</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">2. ARP/RARP</span>
            </li>
            
                    <ul class="toc-h4"><li>
                <span class="toc-link">2.1 ARP包结构</span>
            </li>
            <li>
                <span class="toc-link">2.2 ARP及RARP工作原理</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">2. TCP协议</span>
            </li>
            
                    <ul class="toc-h4"><li>
                <span class="toc-link">2.1 什么TCP协议</span>
            </li>
            <li>
                <span class="toc-link">2.2 三次握手</span>
            </li>
            <li>
                <span class="toc-link">2.3 为什么必须是三次握手</span>
            </li>
            <li>
                <span class="toc-link">2.4 四次挥手</span>
            </li>
            <li>
                <span class="toc-link">2.5 为什么必须是四次挥手</span>
            </li>
            <li>
                <span class="toc-link">2.6 TCP ARQ和滑动窗口协议</span>
            </li>
            
                    <ul class="toc-h5"><li>
                <span class="toc-link">2.6.1 停止等待ARQ</span>
            </li>
            <li>
                <span class="toc-link">2.6.2 连续ARQ</span>
            </li>
            <li>
                <span class="toc-link">2.6.3 滑动窗口协议</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">2.7. TCP的拥塞控制</span>
            </li>
            
                    <ul class="toc-h5"><li>
                <span class="toc-link">2.7.1 慢开始</span>
            </li>
            <li>
                <span class="toc-link">2.7.2 拥塞避免</span>
            </li>
            <li>
                <span class="toc-link">2.7.3 快重传</span>
            </li>
            <li>
                <span class="toc-link">2.7.4 快恢复</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">2.8. TCP与UDP的区别</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">5. DNS域名系统</span>
            </li>
            <li>
                <span class="toc-link">5. HTTP协议</span>
            </li>
            
                    <ul class="toc-h4"><li>
                <span class="toc-link">5.1 什么是http协议</span>
            </li>
            <li>
                <span class="toc-link">5.2 http的报头结构</span>
            </li>
            <li>
                <span class="toc-link">5.3 http methods / get和post的区别</span>
            </li>
            <li>
                <span class="toc-link">5.4 http状态码有哪些</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">6. HTTPS/HTTP2.0/WebSocket</span>
            </li>
            
                    <ul class="toc-h4"><li>
                <span class="toc-link">6.1 HTTPS</span>
            </li>
            
                    <ul class="toc-h5"><li>
                <span class="toc-link">6.1.1 对称加密和非对称加密</span>
            </li>
            <li>
                <span class="toc-link">6.1.2 https的加密方式</span>
            </li>
            <li>
                <span class="toc-link">6.1.3 中间人攻击</span>
            </li>
            <li>
                <span class="toc-link">6.1.4 CA证书</span>
            </li>
            <li>
                <span class="toc-link">6.1.5 HTTPS安全通信机制</span>
            </li>
            <li>
                <span class="toc-link">6.1.5 SSL/TLS</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">6.2 HTTP2.0</span>
            </li>
            
                    <ul class="toc-h5"><li>
                <span class="toc-link">6.2.1 http1.x的缺陷</span>
            </li>
            <li>
                <span class="toc-link">6.2.2 http2.0的优点</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">6.3 WebSocket</span>
            </li>
            
                    </ul><li>
                <span class="toc-link">7. 两台主机的通信过程</span>
            </li>
            
                    <ul class="toc-h4"><li>
                <span class="toc-link">1. 从数据的角度</span>
            </li>
            <li>
                <span class="toc-link">2. 从连接的角度</span>
            </li>
            
                    <ul class="toc-h5"><li>
                <span class="toc-link">基础概念</span>
            </li>
            
                    </ul>
                    </ul><li>
                <span class="toc-link">8. RESTful设计规范</span>
            </li>
            </div><div class="single-post container">
    <div class="post">
      <div class="header">
        <span class="title">面试题——计算机网络</span>
        
        <div class="info">
          <span>📅 2021-04-11</span>
          <span>👦 Tomtom Young</span>
          <span>📖 8965字</span>
          <span>⏱ 18分钟</span>
        </div>
        
      </div>
      <div class="content markdown-body">
        <h3 id="1-七层模型和五层模型">1. 七层模型和五层模型</h3>
<h4 id="11-七层模型与五层模型的介绍">1.1 七层模型与五层模型的介绍</h4>
<p>OSI七层模型：</p>
<ol>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ol>
<p>TCP/IP四层模型</p>
<ol>
<li>应用层</li>
<li>运输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ol>
<p>折中的五层模型</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ol>
<h4 id="12-五层模型各层的作用和协议">1.2 五层模型各层的作用和协议</h4>
<p><strong>1. 物理层</strong></p>
<ul>
<li>物理层上传输数据的单位是比特（bit），就是0/1二进制电信号；</li>
<li>规定了物理设备的标准，比如网线的接口类型、光纤的接口类型。</li>
</ul>
<p><strong>2. 数据链路层</strong></p>
<ul>
<li>发送数据时，数据链路层将网络层传下来的IP数据组装成帧，每一帧包括了数据和必要的控制信息；</li>
<li>接受数据时，帧中的控制信息可以确定信息的开始位置和结束位置，数据链路层就可以提取出信息，上交给网络层；</li>
<li>数据链路层还提供检错和纠错的功能，如果接收到的帧有差错，就丢弃这个帧。</li>
</ul>
<p><strong>3. 网络层 （IP ICMP）</strong></p>
<ul>
<li>网络层给处于不同位置的两台主机提供连接；</li>
<li>网络层使用IP协议，对传输层产生的报文进行分包，因此分完的包也被叫做IP数据报。</li>
</ul>
<p><strong>4. 传输层（TCP UDP）</strong></p>
<ul>
<li>传输层向处于不同位置的两台主机之间的通信提供通用的数据传输服务，使用的方法就是规定不同的进程使用不同的端口；</li>
<li>这里的通用是指，数据传输服务不针对某个应用，而是多个应用可以使用同一个传输层服务；</li>
<li>传输层有分用和复用功能：复用是多个应用同时使用传输层服务；分用是传输层接收到的数据分别交付给上面的应用。</li>
</ul>
<p><strong>5. 应用层（DNS、http、ftp、smtp）</strong></p>
<ul>
<li>应用层的任务是通过进程间的交互来完成特定的网络应用；</li>
<li>应用层的协议定义了应用进程间通信和交互的规则；</li>
<li>不同的网络应用需要不同的协议：域名系统DNS、支持万维网应用的协议http、支持邮件系统的SMTP。</li>
</ul>
<h4 id="13-七层模型中会话层和表示层的作用">1.3 七层模型中会话层和表示层的作用</h4>
<ol>
<li>表示层：让不同应用之间的信息可以相互识别和读取；</li>
<li>会话层：负责建立节点间的会话，让不同应用之间传输信息。</li>
</ol>
<h3 id="2-arprarp">2. ARP/RARP</h3>
<p>ARP(Address Resolution Protocol) 地址解析协议</p>
<p>RARP(Reverse Address Resolution Protocol) 反向地址解析协议</p>
<h4 id="21-arp包结构">2.1 ARP包结构</h4>
<p>RARP包结构和ARP包结构相同</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/arp_1.gif" alt="ARP及RARP简介"></p>
<p><strong>包结构解释：</strong></p>
<p>硬件类型：指明了发送方想知道的硬件接口类型，以太网的值为1；</p>
<p>协议类型：指明了发送方提供的高层协议类型，IP为0800（16进制）；
硬件地址长度和协议长度：指明了硬件地址和高层协议地址的长度，这样ARP报文就可以在任意硬件和任意协议的网络中使用；</p>
<p>操作类型：用来表示这个报文的类型，ARP请求为1，ARP响应为2，RARP请求为3，RARP响应为4；</p>
<p>发送方的硬件地址(0-3字节)：源主机硬件地址的前4个字节；</p>
<p>发送方的硬件地址(4-5字节)：源主机硬件地址的后2个字节；</p>
<p>源IP地址(0-1字节)：源主机IP的前2个字节；</p>
<p>源IP地址(2-3字节)：源主机IP的后2个字节；</p>
<p>目标硬件地址(0-1字节)：目标硬件地址的前2个字节；</p>
<p>目标硬件地址(2-5字节)：目标硬件地址的后4个字节；</p>
<p>目标IP地址(0-3字节)：目标主机的IP地址。</p>
<h4 id="22-arp及rarp工作原理">2.2 ARP及RARP工作原理</h4>
<p>ARP的工作原理如下：</p>
<ol>
<li>首先，每台主机都会在自己的ARP缓冲区 (ARP Cache)中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有﹐就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。</li>
<li>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；</li>
<li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ol>
<p>RARP的工作原理：</p>
<ol>
<li>发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；</li>
<li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；</li>
<li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；</li>
<li>如果不存在，RARP服务器对此不做任何的响应；</li>
<li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li>
</ol>
<h3 id="2-tcp协议">2. TCP协议</h3>
<h4 id="21-什么tcp协议">2.1 什么TCP协议</h4>
<p>TCP(Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、 基于IP的传输层协议。TCP在IP报文的协议号是6。</p>
<h4 id="22-三次握手">2.2 三次握手</h4>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20180717202520531" alt="img"></p>
<ul>
<li>三次握手是指：建立TCP连接时，客户端与服务端发送三次包；</li>
<li>建立连接的过程中要解决三个问题：
<ol>
<li>要使双方都知道对方的存在；</li>
<li>要允许双方协商一些参数（比如窗口大小、时间戳选项）；</li>
<li>要对运输的资源进行分配。</li>
</ol>
</li>
<li>三次握手的过程为：
<ol>
<li>客户端向服务端发送SYN报文</li>
<li>服务端向客户端发送SYN+ACK报文</li>
<li>客户端向服务端发送ACK报文</li>
</ol>
</li>
</ul>
<h4 id="23-为什么必须是三次握手">2.3 为什么必须是三次握手</h4>
<p>如果是两次握手，就变成了客户端向服务端发送请求，服务端收到请求并确认。这样会导致一个问题：</p>
<ul>
<li>如果客户端向服务端发送了一个报文，因为网络延迟，迟迟没有到达服务端，客户端就一直没有收到服务端的响应报文。</li>
<li>客户端再次发送了一个请求报文，这次客户端顺利接到并响应，两者建立了连接，并传输数据，之后连接关闭。</li>
<li>此时，第一次发出的请求报文到达了服务端，服务端响应，两者再次建立了连接，但是客户端已经不会再发送数据了，服务端就一直处于等待状态。</li>
</ul>
<h4 id="24-四次挥手">2.4 四次挥手</h4>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20180717204202563" alt="img"></p>
<ul>
<li>四次挥手是指断开TCP连接时需要双方发送四次包；</li>
<li>四次挥手的过程为：
<ol>
<li>客户端发送FIN+ACK报文</li>
<li>服务端接收到客户端报文，返回ACK报文</li>
<li>服务端发送FIN+ACK报文</li>
<li>客户端接收到服务端报文，返回ACK报文</li>
</ol>
</li>
</ul>
<h4 id="25-为什么必须是四次挥手">2.5 为什么必须是四次挥手</h4>
<p>四次挥手是分为两组的：</p>
<ol>
<li>客户端发送FIN+ACK报文，说明客户端不想再接受数据了；服务端发送ACK报文，说明服务端告知客户端，你不接收了我也不发了。</li>
<li>服务端发送FIN+ACK报文，说明客户端也不想接收数据了；客户端发送ACK报文，说明客户端告知服务端，你不接受我也不发了。</li>
</ol>
<p>通过这两组操作，客户端和服务端都相互告知对方，我不再接受和发送数据了。</p>
<h4 id="26-tcp-arq和滑动窗口协议">2.6 TCP ARQ和滑动窗口协议</h4>
<p>理想的传输条件有以下两个特点：</p>
<ol>
<li>传输信道不产生差错。</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li>
</ol>
<p>我们知道TCP可以进行可靠的通信，而ARQ就是TCP保证可靠传输的机制。</p>
<h5 id="261-停止等待arq">2.6.1 停止等待ARQ</h5>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20170917131716731" alt="img"></p>
<ul>
<li>
<p>无差错情况：</p>
<ol>
<li>A发送分组M1，发送就暂停发送，等待B的确认；</li>
<li>B收到M1就向A发送确认；</li>
<li>A在收到了对M1的确认后，就再发送下一个分组M2；</li>
<li>同样，在收到B对M2的确认后，再发送M3。</li>
</ol>
</li>
<li>
<p>超时重传：</p>
<ol>
<li>B接收M1时检测出了差错，就丢弃M1；</li>
<li>超时重传：A只要过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。</li>
</ol>
</li>
<li>
<p>确认丢失：</p>
<ol>
<li>B所发送的对M1的确认丢失了；</li>
<li>A在设定的超时重传时间内没有收到确认，但无法知道是自己的分组出错、丢失，或者是B发送的确认丢失了；</li>
<li>A在超时计时器到期后就要重传M1。假定B又收到了重传的分组M1，这时丢弃这个重复的分组M1，向A发送确认；</li>
</ol>
</li>
<li>
<p>确认迟到：</p>
<ol>
<li>传输过程中没有出现差错，但B对分组M1的确认迟到了。</li>
<li>A会收到重复的确认，对重复的确认处理很简单：收下后丢弃；</li>
<li>B仍会收到重复的M1，并且同样要丢弃重复的M1，并重传确认。</li>
</ol>
</li>
</ul>
<h5 id="262-连续arq">2.6.2 连续ARQ</h5>
<p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。当使用流水线传输时，就要使用连续ARQ协议和滑动窗口协议。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20170917133154008" alt="img"></p>
<ul>
<li>位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认；</li>
<li>发送方收到了对第1个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，那么现在可以发送窗口内的第6个分组了；</li>
<li>接收方采用累计确认：接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示到这个分组为止所有分组都已经正确收到了；</li>
<li>累积确认缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。</li>
</ul>
<h5 id="263-滑动窗口协议">2.6.3 滑动窗口协议</h5>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20160313203419859" alt="img"></p>
<p>滑动窗口协议在在发送方和接收方之间各自维持一个滑动窗口，发送发是发送窗口，接收方是接收窗口，而且这个窗口是随着时间变化可以向前滑动的。它允许发送方发送多个分组而不需等待确认。TCP的滑动窗口是以字节为单位的。</p>
<ul>
<li>发送窗口中有四个概念：
<ol>
<li>已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）</li>
<li>已发送但未收到确认的数据（位于发送窗口之内）</li>
<li>允许发送但尚未发送的数据（位于发送窗口之内）</li>
<li>发送窗口之外的缓冲区内暂时不允许发送的数据</li>
</ol>
</li>
<li>接收窗口中也有四个概念：
<ol>
<li>已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）</li>
<li>未按序收到的数据（位于接收窗口之内）</li>
<li>允许的数据（位于接收窗口之内）</li>
<li>不允许接收的数据（位于发送窗口之内）</li>
</ol>
</li>
<li>规则：
<ol>
<li>凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。</li>
<li>只有当发送方A收到了接收方的确认报文段时，发送方窗口才可以向前滑动几个序号。</li>
<li>当发送方A发送的数据经过一段时间没有收到确认（由超时计时器控制），就要使用回退N步协议，回到最后接收到确认号的地方，重新发送这部分数据。</li>
</ol>
</li>
</ul>
<h4 id="27-tcp的拥塞控制">2.7. TCP的拥塞控制</h4>
<h5 id="271-慢开始">2.7.1 慢开始</h5>
<p>1.慢开始不是指cwnd的增长速度慢（指数增长），而是指TCP开始发送设置cwnd=1。
2.思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。如下图：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20180610191717379" alt="每经过一个传输轮次，cnwd指数增长"></p>
<p>3.为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限（ssthresh状态变量）
当cnwd＜ssthresh，使用慢开始算法
当cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
当cnwd＞ssthresh，使用拥塞避免算法</p>
<h5 id="272-拥塞避免">2.7.2 拥塞避免</h5>
<p>1.拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。
2.思路：让拥塞窗口cwnd缓慢地增大（按线性规律增长），即每经过一个往返时间RTT就把发送方的拥塞控制窗口加一。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/2018061019263759" alt="慢开始与拥塞避免算法的实现"></p>
<blockquote>
<p>加法增大与乘法减小
乘法减小：无论是慢开始阶段还是拥塞避免，只要出现了网络拥塞（超时），就把慢开始门限值ssthresh减半
加法增大：执行拥塞避免算法后，拥塞窗口线性缓慢增大，防止网络过早出现拥塞</p>
</blockquote>
<h5 id="273-快重传">2.7.3 快重传</h5>
<p>1.快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20180610195854523" alt="快重传示意图"></p>
<p>2.由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</p>
<h5 id="274-快恢复">2.7.4 快恢复</h5>
<p>（与快重传配合使用）</p>
<p>1.采用快恢复算法时，慢开始只在TCP连接建立时和网络出现超时时才使用。
2.当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。
3.考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<blockquote>
<p><strong>注意</strong>
发送方窗口的上限值=Min（接受窗口rwnd，拥塞窗口cwnd）
rwnd＞cwnd 接收方的接收能力限制发送方窗口的最大值
rwnd＜cwnd 网络的拥塞限制发送方窗口的最大值</p>
</blockquote>
<h4 id="28-tcp与udp的区别">2.8. TCP与UDP的区别</h4>
<ol>
<li>TCP面向连接；UDP无连接发送数据；</li>
<li>TCP比较可靠，可以保证数据无差错、不重复、不丢失；UDP不可靠；</li>
<li>TCP是1对1连接；UDP可以1对1，也可以1对多；</li>
<li>TCP头部比较大（20字节）；UDP头部比较小（8字节）；</li>
<li>TCP面向字节流；UDP面向数据报文。</li>
</ol>
<h3 id="5-dns域名系统">5. DNS域名系统</h3>
<h3 id="5-http协议">5. HTTP协议</h3>
<h4 id="51-什么是http协议">5.1 什么是http协议</h4>
<h4 id="52-http的报头结构">5.2 http的报头结构</h4>
<h4 id="53-http-methods--get和post的区别">5.3 http methods / get和post的区别</h4>
<h4 id="54-http状态码有哪些">5.4 http状态码有哪些</h4>
<h3 id="6-httpshttp20websocket">6. HTTPS/HTTP2.0/WebSocket</h3>
<h4 id="61-https">6.1 HTTPS</h4>
<h5 id="611-对称加密和非对称加密">6.1.1 对称加密和非对称加密</h5>
<p><strong>1. 对称加密</strong></p>
<ol>
<li>一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密。</li>
<li>如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</li>
<li>由服务器生成一个密钥并传输给浏览器，那传输过程中密钥被劫持，劫持者就能用密钥解开双方传输的任何内容了。</li>
<li>如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，这样浏览器要预存好世界上所有HTTPS网站的密钥。</li>
</ol>
<p><strong>2. 非对称加密</strong></p>
<ol>
<li>非对称的密钥分为两个密钥：一把叫做私有密钥，一把叫做公开密钥。</li>
<li>私有密钥不能让其他任何人知道；公开密钥则可以随意发布，任何人都可以获得。</li>
<li>发送密文的一方使用公开密钥进行加密处理，对方收到后，用自己的私有密钥进行解密。</li>
<li>应用到浏览器和服务器的双方通信就是：
<ol>
<li>网站服务器拥有公钥A与对应的私钥A；浏览器拥有公钥B与对应的私钥B。</li>
<li>浏览器把公钥B明文传输给服务器。服务器把公钥A明文给传输浏览器。</li>
<li>浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A解密。</li>
<li>服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B解密。</li>
</ol>
</li>
<li>非对称加密算法非常耗时。</li>
</ol>
<h5 id="612-https的加密方式">6.1.2 https的加密方式</h5>
<p><strong>非对称加密+对称加密结合</strong></p>
<ol>
<li>某网站服务器拥有用于非对称加密的公钥A、私钥A。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</li>
<li>服务器拿到后用私钥A解密得到密钥X。</li>
<li>之后双方所有数据都通过密钥X加密解密即可。</li>
</ol>
<h5 id="613-中间人攻击">6.1.3 中间人攻击</h5>
<ol>
<li>某网站服务器有用于非对称加密的公钥A、私钥A。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（中间人当然也拥有公钥B对应的私钥B）。</li>
<li>浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。</li>
<li>中间人劫持后用私钥B解密得到密钥X，再用公钥A加密后传给服务器。</li>
<li>服务器拿到后用私钥A解密得到对称加密的密钥X。</li>
</ol>
<p><strong>中间人掉包了服务器传来的公钥，进而得到了密钥X。<strong>根本原因是</strong>浏览器无法确认收到的公钥是不是网站服务器的</strong>。</p>
<h5 id="614-ca证书">6.1.4 CA证书</h5>
<p>网站在使用HTTPS协议前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器。这里又有一个问题，<strong>证书本身的传输过程中，如何防止被篡改？</strong></p>
<p><strong>数字签名</strong></p>
<p>数字签名是数字证书的“防伪技术”。</p>
<p><strong>数字签名的制作过程：</strong></p>
<ol>
<li>CA机构拥有非对称加密的私钥和公钥。</li>
<li>CA机构对证书明文数据T进行hash。</li>
<li>对hash后的值用私钥加密，得到数字签名S。</li>
</ol>
<p><strong>浏览器验证过程：</strong></p>
<ol>
<li>拿到证书，得到明文T，签名S。</li>
<li>用CA机构的公钥对S解密，得到S。</li>
<li>用证书里指明的hash算法对明文T进行hash得到T。</li>
<li>通过以上步骤，T应当等于S，除非明文或签名被篡改。所以此时比较S是否等于T，等于则表明证书可信。</li>
</ol>
<h5 id="615-https安全通信机制">6.1.5 HTTPS安全通信机制</h5>
<p>前提：浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。</p>
<ol>
<li>
<p><strong>认证服务器：</strong></p>
<p>服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，</p>
</li>
<li>
<p><strong>协商会话密钥：</strong></p>
<p>客户端该公钥与服务器进行加密通信，协商出两个会话密钥：用于对称加密</p>
</li>
<li>
<p><strong>加密通讯：</strong></p>
<p>此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有HTTP数据，都通过会话密钥加密。</p>
</li>
</ol>
<h5 id="615-ssltls">6.1.5 SSL/TLS</h5>
<p><strong>TSL/SSL层就是用来执行上面安全通信机制的协议层。</strong></p>
<p>SSL 是Secure Sockets Layer <strong>安全套接层</strong>。TLS 是 Transport Layer Security <strong>传输层安全协议</strong>。</p>
<h4 id="62-http20">6.2 HTTP2.0</h4>
<h5 id="621-http1x的缺陷">6.2.1 http1.x的缺陷</h5>
<h5 id="622-http20的优点">6.2.2 http2.0的优点</h5>
<ol>
<li>
<p>二进制分帧</p>
</li>
<li>
<p>首部压缩</p>
</li>
<li>
<p>多路复用</p>
</li>
<li>
<p>服务端推送</p>
</li>
</ol>
<h4 id="63-websocket">6.3 WebSocket</h4>
<p>WebSocket的特点：</p>
<ol>
<li>在客户端与服务端之间建立起平等的连接，任何一方都可以发起请求；</li>
<li>WebSocket不受同源策略的限制；</li>
<li>ws、wss分别对应的是80、443。</li>
</ol>
<p>在Vue中使用WebSocket：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-vue" data-lang="vue"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span>&lt;<span style="color:#ff79c6">template</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>  &lt;<span style="color:#ff79c6">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>	&lt;<span style="color:#ff79c6">h1</span>&gt;使用原生websocket&lt;/<span style="color:#ff79c6">h1</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>    &lt;<span style="color:#ff79c6">el-button</span> <span style="color:#ff79c6">@click</span><span style="color:#f1fa8c">=&#34;send&#34;</span>&gt;<span style="color:#50fa7b">发消息</span>&lt;/<span style="color:#50fa7b">el</span><span style="color:#ff79c6">-button</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>  &lt;/<span style="color:#ff79c6">div</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>&lt;/<span style="color:#ff79c6">template</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>&lt;<span style="color:#ff79c6">script</span>&gt;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#ff79c6">export</span> <span style="color:#ff79c6">default</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>  data() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>    <span style="color:#ff79c6">return</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>      path<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;ws://127.0.0.1:5000/&#34;</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>      socket<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;&#34;</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>    };
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>  },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>  mounted() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>    <span style="color:#6272a4">// 初始化
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">this</span>.init();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>  },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>  methods<span style="color:#ff79c6">:</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span>		<span style="color:#6272a4">// 初始化socket
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span style="color:#6272a4"></span>    init<span style="color:#ff79c6">:</span> <span style="color:#8be9fd;font-style:italic">function</span> () {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span>      <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">typeof</span> WebSocket <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#34;undefined&#34;</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span>        alert(<span style="color:#f1fa8c">&#34;您的浏览器不支持socket&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span>      } <span style="color:#ff79c6">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span>        <span style="color:#6272a4">// 实例化socket
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">this</span>.socket <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> WebSocket(<span style="color:#ff79c6">this</span>.path);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span>        <span style="color:#6272a4">// 监听socket连接
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">this</span>.socket.onopen <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.open;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span>        <span style="color:#6272a4">// 监听socket错误信息
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">this</span>.socket.onerror <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.error;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32</span>        <span style="color:#6272a4">// 监听socket消息
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">this</span>.socket.onmessage <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.getMessage;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34</span>      }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35</span>    },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36</span>		<span style="color:#6272a4">// 打开socket
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37</span><span style="color:#6272a4"></span>    open<span style="color:#ff79c6">:</span> <span style="color:#8be9fd;font-style:italic">function</span> (e) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38</span>      console.log(<span style="color:#f1fa8c">&#34;socket连接成功&#34;</span>, e);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39</span>    },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40</span>		<span style="color:#6272a4">// socket连接出错
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41</span><span style="color:#6272a4"></span>    error<span style="color:#ff79c6">:</span> <span style="color:#8be9fd;font-style:italic">function</span> () {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42</span>      console.log(<span style="color:#f1fa8c">&#34;连接错误&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43</span>    },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44</span>		<span style="color:#6272a4">// socket获取消息
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45</span><span style="color:#6272a4"></span>    getMessage<span style="color:#ff79c6">:</span> <span style="color:#8be9fd;font-style:italic">function</span> (msg) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46</span>      console.log(msg);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47</span>    },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48</span>		<span style="color:#6272a4">// socket发送消息
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49</span><span style="color:#6272a4"></span>    send<span style="color:#ff79c6">:</span> <span style="color:#8be9fd;font-style:italic">function</span> () {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50</span>      console.log(<span style="color:#f1fa8c">&#34;发送&#34;</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51</span>      <span style="color:#ff79c6">this</span>.socket.send({
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52</span>        cmd<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;getPrinters&#34;</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53</span>        requestID<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;123458976&#34;</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54</span>        version<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;1.0&#34;</span>,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55</span>      });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56</span>    },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57</span>		<span style="color:#6272a4">// socket关闭
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58</span><span style="color:#6272a4"></span>    close<span style="color:#ff79c6">:</span> <span style="color:#8be9fd;font-style:italic">function</span> (e) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59</span>      console.log(<span style="color:#f1fa8c">&#34;socket连接关闭&#34;</span>, e);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60</span>    },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61</span>  },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62</span>  destroyed() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63</span>    <span style="color:#6272a4">// 销毁监听
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">64</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">this</span>.socket.onclose <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">this</span>.close;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">65</span>  },
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66</span>};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">67</span>&lt;/<span style="color:#ff79c6">script</span>&gt;
</code></pre></div><h3 id="7-两台主机的通信过程">7. 两台主机的通信过程</h3>
<h4 id="1-从数据的角度">1. 从数据的角度</h4>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200118204511270.png" alt="img"></p>
<ol>
<li>
<p>首先在应用层，客户机要访问目的主机的某个应用程序就会要求对方打开对应的固定端口，而此时客户机也会主动打开一个大于1024的随机端口用来和目的主机通信。加上应用层首部，就比如说，telnet，FTP等等：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200118205842427.png" alt="img"></p>
</li>
<li>
<p>到了运输层，上面的整体又会加上TCP首部，TCP的首部格式是这样的：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200119150217198.png" alt="img"></p>
</li>
<li>
<p>但是这个运输层报文不会这样直接到网络层的，<strong>此时要建立TCP三次握手，建立完成后才会传输数据</strong>（第三次握手可携带数据）。以下为TCP三次握手过程：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200119110524457.png" alt="img"></p>
</li>
<li>
<p>当tcp完成三次握手后，再开始进行数据传输，下面为数据到了网络层的样子：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/2020011914592529.png" alt="img"></p>
</li>
<li>
<p>到了网络层，上面的整体又会加上ip的首部，ip的首部格式如下：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200119150117251.png" alt="img"></p>
<p>数据包到了数据链路层变成以下这样：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200119150453924.png" alt="img"></p>
</li>
<li>
<p>到了数据链路层，会加上链路层首部和尾部，下图为帧的格式：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200119151145479.png" alt="img"></p>
<p>数据到物理层是这样的：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200119155740207.png" alt="img"></p>
</li>
<li>
<p>到了主机B那里的各层就一步步把首部和尾部去掉就可以了，这里就不详细说明了。</p>
</li>
</ol>
<h4 id="2-从连接的角度">2. 从连接的角度</h4>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/20200507101107566.jpg" alt="在这里插入图片描述"></p>
<h5 id="基础概念">基础概念</h5>
<blockquote>
<p><strong>IP地址</strong></p>
<p>IP地址被用来给Internet上的电脑一个编号。大家日常见到的情况是每台联网的PC上都需要有IP地址，才能正常通信。我们可以把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”。</p>
<p><strong>子网掩码</strong></p>
<p>子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。</p>
<p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。</p>
<ul>
<li>通过子网掩码，就可以判断两个IP在不在一个局域网内部。</li>
<li>子网掩码可以看出有多少位是网络号，有多少位是主机号</li>
</ul>
<p><strong>ARP缓存表</strong>：</p>
<p>每一个主机都设有一个ARP高速缓存（ARP cache），里面有本局域网上的各主机和路由器的IP地址到MAC地址（硬件地址）的映射表，这些都是该主机目前知道的一些地址</p>
<p><strong>MAC地址表</strong>：</p>
<p>记录着局域网上各主机和路由器的MAC地址与接口的对应关系。</p>
<p><strong>路由表</strong>：</p>
<p>记录着一个子网络到另一个子网络的路径。目的IP地址，下一个路由器地址，网络掩码等。</p>
<p><strong>硬件相关：</strong>
主    机：个人计算机，服务器，打印机等有网卡的设备。
交换器：负责同一子网中不同主机间通信，是根据MAC地址表转发数据帧的。有目的的转发或广播。
集线器：负责同一子网中不同主机间通信，是根据MAC地址表广播数据帧的。只能广播
路由器：负责不同网络之间的通信。</p>
</blockquote>
<p>主机A向目标主机发送报文的简化过程：</p>
<p>根据目标主机IP地址和本机的子网掩码判断，目标主机和主机A是否在一个子网内：</p>
<p><strong>情况1：在同一个子网络内</strong></p>
<ol>
<li>查询本地ARP缓存表，找到目标主机B的IP地址和对应的MAC地址后就会进行数据传输。</li>
<li>查询本地ARP缓存表，没有找到目标主机B的IP地址和对应的MAC地址，广播一个ARP请求，拿到主机B的MAC地址后，再进行数据传输</li>
</ol>
<p><strong>情况2：不在同一个子网络内</strong></p>
<ol>
<li>查询本地ARP缓存表，找到目标主机B的IP地址和网关MAC地址后就会进行数据传输。后面过程有路由器转发（计算主机B和路由器是否在一个网段，如果在，数据报发送给主机B。如果不在，ARP找到下一个路由器MAC地址，把数据报转发给下一个路由器。重复过程直至找到主机B所在的子网络）</li>
<li>查询本地ARP缓存表，没有找到目标主机B的IP地址和网关MAC地址，广播一个ARP请求，拿到网关&gt; MAC地址后，后面过程有路由器转发（同上）</li>
</ol>
<h3 id="8-restful设计规范">8. RESTful设计规范</h3>
<p>RESTful设计规范总结起来就是三句话：</p>
<ol>
<li>根据URL路径就知道请求的是什么资源，不能带动词；</li>
<li>根据mothed就知道要干什么；</li>
<li>根据状态码就知道这个操作的结果。</li>
</ol>

      </div>
      <div class="footer">
        <span><a class="category" href="https://tomtomyoung.top/%20categories/%E9%9D%A2%E8%AF%95/">面试</a></span>
        <span><a class="tag" href="https://tomtomyoung.top/%20tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span>
      </div>
    </div>

    <ul class="menu">
    <li class="menu-item">
        <i class="iconfont icon-top item-btn" id="back_top_btn"></i>
    </li>
    <li class="menu-item">
        <a href="https://tomtomyoung.top/" id="back-btn">
            <i class="iconfont icon-home item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <i class="iconfont icon-switch item-btn" id="switch_btn"></i>
    </li>
    <li class="menu-item">
        <i class="iconfont icon-search item-btn" id="search_btn"></i>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://tomtomyoung.top/post/%E7%AE%97%E6%B3%95-%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/" data-tooltip="算法 树的操作">
            <i class="iconfont icon-left item-btn"></i>
            
        </a>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://tomtomyoung.top/post/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%85%B6%E4%BB%96/" data-tooltip="面试题——优化">
            <i class="iconfont icon-right item-btn"></i>
            
        </a>
    </li>
</ul>

  </div>
</div>

<div class="cover" id="cover">
        <div class="search-container">
    <input type="search" class="docsearch-input search-input" placeholder="搜索关键词" />
    <div id="loading" class="loading-container"></div>
</div>
    </div>
</body>






<script type="text/javascript" src="https://tomtomyoung.top/js/util.min.e0c465f3bff28ca7174df49a60895f8cc6db6c1c8a1811626d1f4b10daf123666e1eefa7ebc5e5f8ffb9e3056411ec5cb066e24e93233cb014bc93056ce5b82b.js" integrity=""></script></html>