<!DOCTYPE html>
<html lang="zh-cn" data-theme="light"><head>
    <meta name="google-site-verification" content="kw1N-Xm6qEr1c9PGuRd0U_T6DXkw_EHsLyz5LpuDDv8" />
    <meta name="msvalidate.01" content="EE98205D30806C22C519683EFC53E9BA" />
    <meta name="baidu-site-verification" content="iPC3wUcQLL" />
    <title>  git 简介 </title>
    <meta charset="utf-8" /><meta name="generator" content="Hugo 0.85.0" /><meta name="viewport" content="width=device-width,initial-scale=1, minimum-scale=1, maximum-scale=1" />
    <meta name="description" itemprop="description"
        content=" git 简介 " />
    <meta name="keywords" itemprop="keywords"
        content=" [git] " />
    <base href="https://tomtomyoung.top/">
    <link rel="shortcut icon" href="https://tomtomyoung.top/favicons//favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tomtomyoung.top/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tomtomyoung.top/favicons/favicon-16x16.png">
    <link rel="canonical" href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/">
    <link rel="stylesheet" type="text/css" href="https://at.alicdn.com/t/font_2450869_iypnqhtzjei.css">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="https://tomtomyoung.top/css/style.min.09c943b7156acb895e836b904b03210ebb20cff98bfa84a5bb45c19c520b3b5d.css" integrity="" type="text/css">
</head><body class="animated fadeInDown">
<div class="main">
  <div class="toc sub-container">
    <div class="toc-header">
        <span>目录</span>
        <span id="read-percentage"></span>
    </div>
    <ul class="toc-h3"><li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#1-git%e7%9a%84%e8%af%9e%e7%94%9f" class="toc-link" data-anchorId="1-git的诞生">1. Git的诞生</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#2-%e9%9b%86%e4%b8%ad%e5%bc%8fvs%e5%88%86%e5%b8%83%e5%bc%8f" class="toc-link" data-anchorId="2-集中式vs分布式">2. 集中式VS分布式</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#21-%e9%9b%86%e4%b8%ad%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f" class="toc-link" data-anchorId="21-集中式版本控制系统">2.1 集中式版本控制系统</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#22-%e5%88%86%e5%b8%83%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f" class="toc-link" data-anchorId="22-分布式版本控制系统">2.2 分布式版本控制系统</a>
                </li>
                
                        </ul><li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#3-git%e7%9a%84%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3" class="toc-link" data-anchorId="3-git的核心思想">3. Git的核心思想</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#4-git%e4%b8%89%e5%a4%a7%e5%88%86%e5%8c%ba" class="toc-link" data-anchorId="4-git三大分区">4. Git三大分区</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#5-%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="toc-link" data-anchorId="5-常用命令的工作原理">5. 常用命令的工作原理</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#diff" class="toc-link" data-anchorId="diff">diff</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#commit" class="toc-link" data-anchorId="commit">commit</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#checkout" class="toc-link" data-anchorId="checkout">checkout</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#reset" class="toc-link" data-anchorId="reset">reset</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#merge" class="toc-link" data-anchorId="merge">merge</a>
                </li>
                
                        <ul class="toc-h5"><li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#fast-forward" class="toc-link" data-anchorId="fast-forward">Fast-forward</a>
                </li>
                <li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#recursive" class="toc-link" data-anchorId="recursive">Recursive</a>
                </li>
                
                        </ul>
                        </ul><li>
                    <a href="https://tomtomyoung.top/post/git-%E7%AE%80%E4%BB%8B/#6-%e5%90%88%e5%b9%b6%e5%88%86%e6%94%af%e5%8e%9f%e7%90%86" class="toc-link" data-anchorId="6-合并分支原理">6. 合并分支原理</a>
                </li>
                </div><div class="single-post container">
    <div class="post">
      <div class="header">
        <span class="title">git 简介</span>
        
        <div class="info">
          <span>📅 2020-12-25</span>
          <span>👦 Tomtom Young</span>
          <span>📖 5854字</span>
          <span>⏱ 12分钟</span>
        </div>
        
      </div>
      <div class="content markdown-body">
        <h3 id="1-git的诞生">1. Git的诞生</h3>
<blockquote>
<p>转载廖雪峰的官方网站中的部分内容：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202815778784">https://www.liaoxuefeng.com/wiki/896043488029600/896202815778784</a></p>
</blockquote>
<p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p>
<p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p>
<p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p>
<p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p>
<p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p>
<p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p>
<p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p>
<p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p>
<p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p>
<h3 id="2-集中式vs分布式">2. 集中式VS分布式</h3>
<blockquote>
<p>转载廖雪峰的官方网站中的部分内容：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248</a></p>
</blockquote>
<p>Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p>
<h4 id="21-集中式版本控制系统">2.1 集中式版本控制系统</h4>
<p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/l" alt="central-repo"></p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p>
<h4 id="22-分布式版本控制系统">2.2 分布式版本控制系统</h4>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/l" alt="distributed-repo"></p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<h3 id="3-git的核心思想">3. Git的核心思想</h3>
<blockquote>
<p>转载Git官方网站部分内容：<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F</a></p>
</blockquote>
<p>简单地说，Git 究竟是怎样的一个系统呢？ 请注意接下来的内容非常重要，若你理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。 在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS、Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。</p>
<p><strong>直接记录快照，而非差异比较</strong></p>
<p>Git 和其它版本控制系统的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 <strong>基于差异（delta-based）</strong> 的版本控制）。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/deltas.png" alt="存储每个文件与初始版本的差异。"></p>
<p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/snapshots.png" alt="Git 存储项目随时间改变的快照。"></p>
<p><strong>近乎所有操作都是本地执行</strong></p>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p>
<p>举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来。它只需直接从本地数据库中读取。 你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>
<p>这也意味着你在离线时，几乎可以进行任何操作。 如你在飞机或火车上想做些工作，就能愉快地提交（到你的 <strong>本地</strong> 副本，还记得吗？）， 直到有网络连接时再上传。</p>
<p><strong>Git 保证完整性</strong></p>
<p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>24b9da6552252987aa493b52f8696cd6d3b00373
</code></pre></div><p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<p><strong>Git 一般只添加数据</strong></p>
<p>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。</p>
<h3 id="4-git三大分区">4. Git三大分区</h3>
<p>Git 本地数据管理，大概可以分为三个区：<strong>工作区（Working Directory）</strong>、<strong>暂存区（Stage ）<strong>和</strong>版本库（commit History）</strong>。</p>
<ul>
<li>工作区: 直接编辑文件的地方，肉眼可见直接操作。</li>
<li>暂存区：数据（快照）暂时存放的地方。</li>
<li>版本库：存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程git仓库了。</li>
</ul>
<p>处于Git 控制下的文件有三种状态： <strong>已修改（modified）</strong> 、 <strong>已暂存（staged）</strong>、 <strong>已提交（committed）</strong></p>
<ul>
<li>已修改：表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交：表示数据已经安全地保存在本地数据库中。</li>
</ul>
<blockquote>
<p>转载codesheep部分内容：<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F</a></p>
</blockquote>
<p>我们可以用一张图来清楚的了解三个分区和文件的三种状态和 Git 命令的关系：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>我们先看由下而上的路径，首先<strong>工作区</strong>就是我们当前的文件目录，我们改完代码，用<code>git add</code>命令把当前文件加入<strong>暂存区</strong>，然后<code>git commit</code>把<strong>暂存区</strong>生成的快照提交到<strong>本地仓库</strong>，最后再用<code>git push</code>命令把<strong>本地仓库</strong>的提交复制到<strong>远程仓库</strong>，也就是<code>Github</code>之类的在线仓库。</p>
<p>而由上到下的路径其实也很好理解，<code>git pull</code>用来将<strong>远程仓库</strong>的最新提交拉取到<strong>本地仓库</strong>，<code>git reset -- files</code> 用来撤销最后一次<code>git add files</code>，也就是撤销<code>commit</code>，这是我们前面提到的回滚的一种办法；<code>git checkout -- files</code>则是把文件从<strong>暂存区</strong>复制到工作区，用来丢弃本地修改（也就是覆盖掉还未<code>add</code>到暂存区的改动）。</p>
<h3 id="5--常用命令的工作原理">5.  常用命令的工作原理</h3>
<h4 id="diff">diff</h4>
<p>上一篇文章中我们讲了<code>git diff</code>可以直观的看到<strong>工作区</strong>和<strong>暂存区</strong>的差异，这里我们画图演示下不同的<code>diff</code>是如何比较的：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<ul>
<li><code>git diff</code>，不加任何参数，将工作区（未<code>add</code>的内容）和暂存区进行比较；</li>
<li><code>git diff HEAD</code>，将工作区与<code>HEAD</code>指针指向的<code>commit</code>进行比较，一般来说我们当前的改动就是在<code>HEAD</code>指向的<code>commit</code>的基础上进行改动；</li>
<li><code>git diff --cached</code>，将暂存区与当前<code>commit</code>进行比较；</li>
<li><code>git diff dev</code>，将工作区与目标分支的最新<code>commit</code>进行比较；</li>
<li><code>git diff [commitId_1] [commitId_2]</code>，将两个<code>commit</code>进行比较。</li>
</ul>
<h4 id="commit">commit</h4>
<p>前面我们说了，<code>commit</code>会在暂存区生成快照，然后推到本地仓库，这里我们考虑三种情况下的提交：</p>
<ul>
<li>当前<code>HEAD</code>指向末尾的<code>commit</code>：</li>
</ul>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<ul>
<li>当前<code>HEAD</code>指向中间的<code>commit</code>，此时提交就会再分离出一条新的路线，因此后续的分支合并就不可避免地要派上用场。</li>
</ul>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<ul>
<li>希望用新提交覆盖前一个提交：<code>git commit --amend</code>：</li>
</ul>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>这个使用场景也非常广泛，比如我们<code>git commit</code>后才发现漏改了点东西，这个时候如果再改再提交，就会导致对一个错误的修改用了两个<code>commit</code>，在<code>git log</code>上看将会非常丑，对于我们自己做小<code>demo</code>时可能无所谓，对于一些大项目或者开源项目，本来<code>commit</code>就很多，这样胡乱地增加<code>commit</code>必然是不能接受的。</p>
<p>如上图所示，我们新增的<code>commit</code>会代替原来的<code>commit</code>的位置，而旧<code>commit</code>则被抛弃掉。</p>
<h4 id="checkout">checkout</h4>
<p>当我们使用<code>git checkout [branch_name]</code>切换分支时，如下图所示：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p><code>dev</code>分支会把其中的内容复制到暂存区和工作区中，覆盖掉<code>master</code>的版本，而只存在于<code>master</code>的文件则会被删除。</p>
<h4 id="reset">reset</h4>
<p>下图展示了回滚的情况，具体的三种情况请仔细看下方的描述：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<ul>
<li><code>git reset [commitId] --sort</code>，这是最弱的回滚方式，只改变<code>commit</code>信息，不影响<strong>暂存区</strong>和<strong>工作区</strong>；</li>
<li><code>git reset [commitId]</code>，不携带参数时，默认只回滚<strong>暂存区</strong>，也就是把<code>dks8v</code>所在的信息复制到<strong>暂存区</strong>，但是不影响<strong>工作区</strong>；</li>
<li><code>git reset [commitId] --hard</code>，这种方式则能回滚<strong>工作区</strong>和<strong>暂存区</strong>。</li>
</ul>
<h4 id="merge">merge</h4>
<p><code>Git</code>的合并有许多策略，默认情况下<code>Git</code>会帮助我们挑选合适的策略，当然如果我们需要手动指定，可以使用：<code>git merge -s [策略名称]</code>，了解 <code>Git</code> 合并策略的原理可以使你对合并结果有一个准确的预期。</p>
<h5 id="fast-forward">Fast-forward</h5>
<p><code>Fast-forward</code>是最简单的一种合并策略，如我们前面示例的图所示，<code>dev</code>分支是<code>master</code>分支的祖先节点，那么合并<code>git merge dev</code>的话，只会将<code>dev</code>指向<code>master</code>当前位置，<code>Fast-forward</code>是<code>Git</code>合并两个<strong>没有分叉</strong>的分支时的默认行为。</p>
<h5 id="recursive">Recursive</h5>
<p><code>Recursive</code>是<code>Git</code>在合并两个<strong>有分叉</strong>的分支时的默认行为，简单的说，是递归的进行三路合并。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>这里出现了一个新名词——<code>三路合并（three-way merge）</code>，也是我们接下来讲解的重点。我们先搞清楚合并的整体链路。</p>
<ul>
<li>首先<code>dev</code>分支的<code>c5k8x</code>与<code>HEAD</code>指向的<code>sf22x</code>，再加上它们的最近公共祖先<code>a23c4</code>先进行一次三路合并；</li>
<li>然后将合并后的结果拷贝到<strong>暂存区</strong>和<strong>工作区</strong>；</li>
<li>再然后产生一次新的提交，该提交的祖先为<code>dev</code>和<code>原master</code>；</li>
</ul>
<h3 id="6-合并分支原理">6. 合并分支原理</h3>
<p>首先，我们来看看两个文件如何合并：</p>
<p>下图所示为test.py中某一行的代码，如果我们要将A/B两个版本合并，就需要确定是A修改了B，还是B修改了A，亦或者两者都修改了，显然这种情况下分辨不出来。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>因此，为了实现两个文件的合并，我们引入三路合并：</p>
<p>如下图所示，很显然A与Base版本相同，B版本的修改比A版本新，因此将A/B合并后，得到的就是B版本。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>聪明的读者看完上面的例子，就会想到，要是A/B和Base都不一样怎么办？这就是接下来要讲的问题了。</p>
<p><strong>冲突</strong></p>
<p>当出现下图这种情况时，一般就需要我们手动解决冲突了。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>也就是我们在合并代码时往往会看到的一种情况：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#ff79c6">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span> HEAD
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>print(<span style="color:#f1fa8c">&#34;hello&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#ff79c6">=======</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>print(<span style="color:#f1fa8c">&#34;fxxk&#34;</span>)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#ff79c6">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span> B
</code></pre></div><p>对于新手而言，看到这个箭头可能有点摸不着头脑，到底哪个是哪个呢？其实分辨起来很简单，中间的<code>=======</code>是分隔符，到最上方的<code>&lt;&lt;&lt;&lt;&lt;&lt;</code>之间的内容，是<code>HEAD</code>版本，也就是当前的<code>master</code>分支，而到最下方<code>&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容，则是分支<code>B</code>的，我们只需要删除箭头，保留所需要的版本即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>print(<span style="color:#f1fa8c">&#34;hello&#34;</span>)
</code></pre></div><p>最终合并结果：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p><strong>递归三路合并</strong></p>
<p>在实际的生产环境中，Git的分支往往非常繁杂，会导致合并A/B时，能找到多个A/B的共同祖先，而所谓的递归三路合并就是，对它们的共同祖先继续找共同祖先，直到找到唯一一个共同祖先为止，这样可以减少冲突的概率。</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>如上图所示，我们要合并5和6，就需要先找到5/6的共同祖先——2和3，然后再继续找共同祖先——1，当我们找到唯一祖先时，开始递归三路合并，先对1、2、3进行三路合并，得到临时节点2'/B：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>
<p>接下来继续对2、5、6进行三路合并，得到7/C：</p>
<p><img src="https://blogimg-1302307650.cos.ap-shanghai.myqcloud.com/640" alt="图片"></p>

      </div>
      <div class="footer">
        <span><a class="category" href="https://tomtomyoung.top/%20categories/%E5%89%8D%E7%AB%AF/">前端</a></span>
        <span><a class="tag" href="https://tomtomyoung.top/%20tags/git/">git</a></span>
        
      </div>
    </div>

    <ul class="menu">
    <li class="menu-item">
        <a href="javascript:void(0);" id="back-top-btn">
            <i class="iconfont icon-top item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="https://tomtomyoung.top/" id="back-btn">
            <i class="iconfont icon-home item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="switch-btn">
            <i class="iconfont icon-switch item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="search-btn">
            <i class="iconfont icon-search item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://tomtomyoung.top/post/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/" data-tooltip="字符集和编码">
            <i class="iconfont icon-left item-btn"></i>
            
        </a>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://tomtomyoung.top/post/%E8%BD%AC%E8%BD%BD%E6%9C%BA%E5%99%A8%E4%B8%8E%E4%BA%BA%E7%B1%BB%E8%A7%86%E8%A7%89%E8%83%BD%E5%8A%9B%E7%9A%84%E5%B7%AE%E8%B7%9D3/" data-tooltip="(转载)机器与人类视觉能力的差距（3）">
            <i class="iconfont icon-right item-btn"></i>
            
        </a>
    </li>
</ul>

  </div>
</div>

<div class="cover" id="cover">
        <div class="search-container">
    <input type="search" class="docsearch-input search-input" placeholder="搜索关键词" id="search-input" />
    <div id="loading" class="loading-container">
        <span>搜索中...</span>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
    docsearch({
        apiKey: 'f7f9aeb8485880cfd0e747129ea4ddf9',
        indexName: 'blogsearch',
        appId: 'SGIZDO9IMB',
        inputSelector: '.docsearch-input',
        debug: true,
        algoliaOptions: {
            hitsPerPage: 50
        },
        
        
        
        queryHook: query => {
            document.querySelector('#loading').classList.add('show');
            
        },
        transformData: tips => {
            document.querySelector('#loading').classList.remove('show');
        }
    });
</script>
    </div>
</body>






<script type="text/javascript" src="https://tomtomyoung.top/js/util.min.116a48de1fb1adecf15596166c88baf367a7eb7864965ca7e1e969abde4b8736d3527693ca3eb2990a41557c70a680764bb8b52cd14eb98529938ba37d08d708.js" integrity=""></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168042857-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</html>