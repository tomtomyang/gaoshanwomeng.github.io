<!DOCTYPE html>
<html lang="zh-cn" data-theme="light"><head>
    <meta name="google-site-verification" content="kw1N-Xm6qEr1c9PGuRd0U_T6DXkw_EHsLyz5LpuDDv8" />
    <meta name="msvalidate.01" content="EE98205D30806C22C519683EFC53E9BA" />
    <meta name="baidu-site-verification" content="iPC3wUcQLL" />
    <title>  js 正则表达式 </title>
    <meta charset="utf-8" /><meta name="generator" content="Hugo 0.85.0" /><meta name="viewport" content="width=device-width,initial-scale=1, minimum-scale=1, maximum-scale=1" />
    <meta name="description" itemprop="description"
        content=" js 正则表达式 " />
    <meta name="keywords" itemprop="keywords"
        content=" [js 正则表达式] " />
    <base href="https://gaoshanwomeng.github.io/">
    <link rel="shortcut icon" href="https://gaoshanwomeng.github.io/favicons//favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="https://gaoshanwomeng.github.io/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://gaoshanwomeng.github.io/favicons/favicon-16x16.png">
    <link rel="canonical" href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
    <link rel="stylesheet" type="text/css" href="https://at.alicdn.com/t/font_2450869_iypnqhtzjei.css">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="https://gaoshanwomeng.github.io/css/style.min.50b2601e373617d56bada22a63c4678e95dc55c0ba89859ca0224f471279af33.css" integrity="" type="text/css">
</head><body>
<div class="main animated fadeInDown">
  <div class="toc sub-container">
    <div class="toc-header">
        <span>目录</span>
        <span id="read-percentage"></span>
    </div>
    <ul class="toc-h3"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#1-%e4%b8%a4%e7%a7%8d%e6%a8%a1%e7%b3%8a%e5%8c%b9%e9%85%8d" class="toc-link">1 两种模糊匹配</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#11-%e6%a8%aa%e5%90%91%e6%a8%a1%e7%b3%8a%e5%8c%b9%e9%85%8d" class="toc-link">1.1 横向模糊匹配</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#12-%e7%ba%b5%e5%90%91%e6%a8%a1%e7%b3%8a%e5%8c%b9%e9%85%8d" class="toc-link">1.2 纵向模糊匹配</a>
                </li>
                
                        </ul><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#2-%e5%ad%97%e7%ac%a6%e7%bb%84" class="toc-link">2. 字符组</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#21-%e8%8c%83%e5%9b%b4%e8%a1%a8%e7%a4%ba%e6%b3%95" class="toc-link">2.1 范围表示法</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#22-%e6%8e%92%e9%99%a4%e5%ad%97%e7%ac%a6%e7%bb%84" class="toc-link">2.2 排除字符组</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#23-%e5%b8%b8%e8%a7%81%e7%9a%84%e7%ae%80%e5%86%99%e5%bd%a2%e5%bc%8f" class="toc-link">2.3 常见的简写形式</a>
                </li>
                
                        </ul><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#3-%e9%87%8f%e8%af%8d" class="toc-link">3. 量词</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#31-%e7%ae%80%e5%86%99%e5%bd%a2%e5%bc%8f" class="toc-link">3.1 简写形式</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#32-%e8%b4%aa%e5%a9%aa%e5%8c%b9%e9%85%8d%e5%92%8c%e6%83%b0%e6%80%a7%e5%8c%b9%e9%85%8d" class="toc-link">3.2 贪婪匹配和惰性匹配</a>
                </li>
                
                        </ul><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#4-%e5%a4%9a%e9%80%89%e5%88%86%e6%94%af" class="toc-link">4. 多选分支</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#5-%e6%a1%88%e4%be%8b%e5%88%86%e6%9e%90" class="toc-link">5. 案例分析</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#51-%e5%8c%b9%e9%85%8d16%e8%bf%9b%e5%88%b6%e9%a2%9c%e8%89%b2%e5%80%bc" class="toc-link">5.1 匹配16进制颜色值</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#52-%e5%8c%b9%e9%85%8d%e6%97%b6%e9%97%b4" class="toc-link">5.2 匹配时间</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#53-%e5%8c%b9%e9%85%8d%e6%97%a5%e6%9c%9f" class="toc-link">5.3 匹配日期</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#54-window%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84" class="toc-link">5.4 window操作系统文件路径</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#55-%e5%8c%b9%e9%85%8did" class="toc-link">5.5 匹配id</a>
                </li>
                
                        </ul><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/#6%e5%b0%8f%e7%bb%93" class="toc-link">6.小结</a>
                </li>
                </div><div class="single-post container">
    <div class="post">
      <div class="header">
        <span class="title">js 正则表达式</span>
        
        <div class="info">
          <span>📅 2021-03-03</span>
          <span>👦 Tomtom Young</span>
          <span>📖 3807字</span>
          <span>⏱ 8分钟</span>
        </div>
        
      </div>
      <div class="content markdown-body">
        <h3 id="1-两种模糊匹配">1 两种模糊匹配</h3>
<p>如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的&quot;hello&quot;这个子串。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/hello/</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;hello&#34;</span>) );
</code></pre></div><p>正则表达式之所以强大，是因为其能实现模糊匹配。</p>
<p>而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。</p>
<h4 id="11-横向模糊匹配">1.1 横向模糊匹配</h4>
<p>横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。</p>
<p>其实现的方式是使用量词。譬如<code>{m,n}</code>，表示连续出现最少m次，最多n次。</p>
<p>比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。测试如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/ab{2,5}c/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;abc abbc abbbc abbbbc abbbbbc abbbbbbc&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;abbc&#34;, &#34;abbbc&#34;, &#34;abbbbc&#34;, &#34;abbbbbc&#34;]
</span></code></pre></div><p>注意：案例中用的正则是<code>/ab{2,5}c/g</code>，后面多了g，它是正则的一个修饰符。表示全局匹配，即在目标字符串中按顺序找到满足匹配模式的所有子串，强调的是“所有”，而不只是“第一个”。g是单词global的首字母。</p>
<h4 id="12-纵向模糊匹配">1.2 纵向模糊匹配</h4>
<p>纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。</p>
<p>其实现的方式是使用字符组。譬如<code>[abc]</code>，表示该字符是可以字符“a”、“b”、“c”中的任何一个。</p>
<p>比如<code>/a[123]b/</code>可以匹配如下三种字符串：&ldquo;a1b&rdquo;、&ldquo;a2b&rdquo;、&ldquo;a3b&rdquo;。测试如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/a[123]b/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;a0b a1b a2b a3b a4b&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;a1b&#34;, &#34;a2b&#34;, &#34;a3b&#34;]
</span></code></pre></div><p>以上就是本章讲的主体内容，只要掌握横向和纵向模糊匹配，就能解决很大部分正则匹配问题。</p>
<p>接下来的内容就是展开说了，如果对此都比较熟悉的话，可以跳过，直接看本章案例那节。</p>
<h3 id="2-字符组">2. 字符组</h3>
<p>需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如[abc]，表示匹配一个字符，它可以是“a”、“b”、“c”之一。</p>
<h4 id="21-范围表示法">2.1 范围表示法</h4>
<p>如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。</p>
<p>比如<code>[123456abcdefGHIJKLM]</code>，可以写成<code>[1-6a-fG-M]</code>。用连字符-来省略和简写。</p>
<p>因为连字符有特殊用途，那么要匹配“a”、“-”、“z”这三者中任意一个字符，该怎么做呢？</p>
<p>不能写成[a-z]，因为其表示小写字符中的任何一个字符。</p>
<p>可以写成如下的方式：<code>[-az]</code>或<code>[az-]</code>或<code>[a\-z]</code>。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。</p>
<h4 id="22-排除字符组">2.2 排除字符组</h4>
<p>纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是&quot;a&quot;、&ldquo;b&rdquo;、&ldquo;c&rdquo;。</p>
<p>此时就是排除字符组（反义字符组）的概念。例如<code>[^abc]</code>，表示是一个除&quot;a&quot;、&ldquo;b&rdquo;、&ldquo;c&quot;之外的任意一个字符。字符组的第一位放^（脱字符），表示求反的概念。</p>
<h4 id="23-常见的简写形式">2.3 常见的简写形式</h4>
<p>有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。</p>
<p><code>\d</code>就是<code>[0-9]</code>。表示是一位数字。记忆方式：其英文是digit（数字）。</p>
<p><code>\D</code>就是<code>[^0-9]</code>。表示除数字外的任意字符。</p>
<p><code>\w</code>就是<code>[0-9a-zA-Z_]</code>。表示数字、大小写字母和下划线。记忆方式：w是word的简写，也称单词字符。</p>
<p><code>\W</code>是<code>[^0-9a-zA-Z_]</code>。非单词字符。</p>
<p>\s是<code>[ \t\v\n\r\f]</code>。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s是space character的首字母。</p>
<p><code>\S</code>是<code>[^ \t\v\n\r\f]</code>。 非空白符。</p>
<p><code>.</code>就是<code>[^\n\r\u2028\u2029]</code>。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号&hellip;中的每个点，都可以理解成占位符，表示任何类似的东西。</p>
<p>如果要匹配任意字符怎么办？可以使用<code>[\d\D]</code>、<code>[\w\W]</code>、<code>[\s\S]</code>和<code>[^]</code>中任何的一个。</p>
<h3 id="3-量词">3. 量词</h3>
<p>量词也称重复。掌握{m,n}的准确含义后，只需要记住一些简写形式。</p>
<h4 id="31-简写形式">3.1 简写形式</h4>
<p><code>{m,}</code>表示至少出现m次。</p>
<p><code>{m}</code>等价于<code>{m,m}</code>，表示出现m次。</p>
<p><code>?</code> 等价于<code>{0,1}</code>，表示出现或者不出现。记忆方式：问号的意思表示，有吗？</p>
<p><code>+</code>等价于<code>{1,}</code>，表示出现至少一次。记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。</p>
<p><code>*</code> 等价于<code>{0,}</code>，表示出现任意次，有可能不出现。记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。</p>
<h4 id="32-贪婪匹配和惰性匹配">3.2 贪婪匹配和惰性匹配</h4>
<p>看如下的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/\d{2,5}/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;123 1234 12345 123456&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;123&#34;, &#34;1234&#34;, &#34;12345&#34;, &#34;12345&#34;]
</span></code></pre></div><p>其中正则/\d{2,5}/，表示数字连续出现2到5次。会匹配2位、3位、4位、5位连续数字。</p>
<p>但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要5个。你能给我3个，我就3要个。反正只要在能力范围内，越多越好。</p>
<p>我们知道有时贪婪不是一件好事（请看文章最后一个例子）。而惰性匹配，就是尽可能少的匹配：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/\d{2,5}?/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;123 1234 12345 123456&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;12&#34;, &#34;12&#34;, &#34;34&#34;, &#34;12&#34;, &#34;34&#34;, &#34;12&#34;, &#34;34&#34;, &#34;56&#34;]
</span></code></pre></div><p>其中<code>/\d{2,5}?/</code>表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。</p>
<p>通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：</p>
<p><code>{m,n}?</code>
<code>{m,}?</code>
<code>??</code>
<code>+?</code>
<code>*?</code></p>
<p>对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？</p>
<h3 id="4-多选分支">4. 多选分支</h3>
<p>一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。</p>
<p>具体形式如下：(p1|p2|p3)，其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何之一。</p>
<p>例如要匹配&quot;good&quot;和&quot;nice&quot;可以使用<code>/good|nice/</code>。测试如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/good|nice/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;good idea, nice try.&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;good&#34;, &#34;nice&#34;]
</span></code></pre></div><p>但有个事实我们应该注意，比如我用<code>/good|goodbye/</code>，去匹配&quot;goodbye&quot;字符串时，结果是&quot;good&rdquo;：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/good|goodbye/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;goodbye&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;good&#34;]复制代码
</span></code></pre></div><p>而把正则改成<code>/goodbye|good/</code>，结果是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/goodbye|good/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;goodbye&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;goodbye&#34;]复制代码
</span></code></pre></div><p>也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。</p>
<h3 id="5-案例分析">5. 案例分析</h3>
<p>匹配字符，无非就是字符组、量词和分支结构的组合使用罢了。</p>
<p>下面找几个例子演练一下（其中，每个正则并不是只有唯一写法）：</p>
<h4 id="51-匹配16进制颜色值">5.1 匹配16进制颜色值</h4>
<p><strong>要求匹配：</strong></p>
<p>#ffbbad</p>
<p>#Fc01DF</p>
<p>#FFF</p>
<p>#ffE</p>
<p><strong>分析：</strong></p>
<p>表示一个16进制字符，可以用字符组<code>[0-9a-fA-F]</code>。</p>
<p>其中字符可以出现3或6次，需要是用量词和分支结构。</p>
<p>使用分支结构时，需要注意顺序。</p>
<p><strong>正则如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;#ffbbad #Fc01DF #FFF #ffE&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( string.match(regex) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; [&#34;#ffbbad&#34;, &#34;#Fc01DF&#34;, &#34;#FFF&#34;, &#34;#ffE&#34;]
</span></code></pre></div><h4 id="52-匹配时间">5.2 匹配时间</h4>
<p>以24小时制为例。</p>
<p><strong>要求匹配：</strong></p>
<p>23:59</p>
<p>02:07</p>
<p><strong>分析：</strong></p>
<p>共4位数字，第一位数字可以为[0-2]。</p>
<p>当第1位为2时，第2位可以为[0-3]，其他情况时，第2位为[0-9]。</p>
<p>第3位数字为[0-5]，第4位为[0-9]</p>
<p><strong>正则如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/^([01][0-9]|[2][0-3]):[0-5][0-9]$/</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;23:59&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;02:07&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#6272a4">// =&gt; true
</span></code></pre></div><p>如果也要求匹配7:9，也就是说时分前面的0可以省略。</p>
<p>此时正则变成：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;23:59&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;02:07&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;7:9&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#6272a4">// =&gt; true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span style="color:#6272a4">// =&gt; true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4">// =&gt; true
</span></code></pre></div><h4 id="53-匹配日期">5.3 匹配日期</h4>
<p>比如yyyy-mm-dd格式为例。</p>
<p><strong>要求匹配：</strong></p>
<p>2017-06-10</p>
<p><strong>分析：</strong></p>
<p>年，四位数字即可，可用[0-9]{4}。</p>
<p>月，共12个月，分两种情况01、02、……、09和10、11、12，可用(0[1-9]|1[0-2])。</p>
<p>日，最大31天，可用(0[1-9]|[12][0-9]|3[01])。</p>
<p><strong>正则如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;2017-06-10&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#6272a4">// =&gt; true
</span></code></pre></div><h4 id="54-window操作系统文件路径">5.4 window操作系统文件路径</h4>
<p><strong>要求匹配：</strong></p>
<p>F:\study\javascript\regex\regular expression.pdf</p>
<p>F:\study\javascript\regex\</p>
<p>F:\study\javascript</p>
<p>F:\</p>
<p><strong>分析：</strong></p>
<p>整体模式是: 盘符:\文件夹\文件夹\文件夹\</p>
<p>其中匹配F:\，需要使用<code>[a-zA-Z]:\\</code>，其中盘符不区分大小写，注意\字符需要转义。</p>
<p>文件名或者文件夹名，不能包含一些特殊字符，此时我们需要排除字符组<code>[^\\:*&lt;&gt;|&quot;?\r\n/]</code>来表示合法字符。另外不能为空名，至少有一个字符，也就是要使用量词+。因此匹配“文件夹\”，可用<code>[^\\:*&lt;&gt;|&quot;?\r\n/]+\\</code>。</p>
<p>另外“文件夹\”，可以出现任意次。也就是<code>([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*</code>。其中括号提供子表达式。</p>
<p>路径的最后一部分可以是“文件夹”，没有\，因此需要添加<code>([^\\:*&lt;&gt;|&quot;?\r\n/]+)?</code>。</p>
<p>最后拼接成了一个看起来比较复杂的正则：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/^[a-zA-Z]:\\([^\\:*&lt;&gt;|&#34;?\r\n/]+\\)*([^\\:*&lt;&gt;|&#34;?\r\n/]+)?$/</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;F:\\study\\javascript\\regex\\regular expression.pdf&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;F:\\study\\javascript\\regex\\&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;F:\\study\\javascript&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>console.log( regex.test(<span style="color:#f1fa8c">&#34;F:\\&#34;</span>) ); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span style="color:#6272a4">// =&gt; true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4">// =&gt; true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#6272a4">// =&gt; true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span><span style="color:#6272a4">// =&gt; true
</span></code></pre></div><p>其中，JS中字符串表示\时，也要转义。</p>
<h4 id="55-匹配id">5.5 匹配id</h4>
<p>要求从</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>&lt;<span style="color:#ff79c6">div</span> <span style="color:#50fa7b">id</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;container&#34;</span> <span style="color:#50fa7b">class</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;main&#34;</span>&gt;&lt;/<span style="color:#ff79c6">div</span>&gt;
</code></pre></div><p>提取出id=&ldquo;container&rdquo;。</p>
<p>可能最开始想到的正则是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/id=&#34;.*&#34;/</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;&lt;div id=&#34;container&#34; class=&#34;main&#34;&gt;&lt;/div&gt;&#39;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log(string.match(regex)[<span style="color:#bd93f9">0</span>]); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; id=&#34;container&#34; class=&#34;main&#34;
</span></code></pre></div><p>因为.是通配符，本身就匹配双引号的，而量词*又是贪婪的，当遇到container后面双引号时，不会停下来，会继续匹配，直到遇到最后一个双引号为止。</p>
<p>解决之道，可以使用惰性匹配：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/id=&#34;.*?&#34;/</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;&lt;div id=&#34;container&#34; class=&#34;main&#34;&gt;&lt;/div&gt;&#39;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log(string.match(regex)[<span style="color:#bd93f9">0</span>]); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; id=&#34;container&#34;
</span></code></pre></div><p>当然，这样也会有个问题。效率比较低，因为其匹配原理会涉及到“回溯”这个概念（这里也只是顺便提一下，第四章会详细说明）。可以优化如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> regex <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">/id=&#34;[^&#34;]*&#34;/</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> string <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#39;&lt;div id=&#34;container&#34; class=&#34;main&#34;&gt;&lt;/div&gt;&#39;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>console.log(string.match(regex)[<span style="color:#bd93f9">0</span>]); 
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#6272a4">// =&gt; id=&#34;container&#34;复制代码
</span></code></pre></div><h3 id="6小结">6.小结</h3>
<p>字符匹配相关的案例，挺多的，不一而足。</p>
<p>掌握字符组和量词就能解决大部分常见的情形，也就是说，当你会了这二者，JS正则算是入门了。</p>

      </div>
      <div class="footer">
        <span><a class="category" href="https://gaoshanwomeng.github.io/%20categories/%E5%89%8D%E7%AB%AF/">前端</a><a class="category" href="https://gaoshanwomeng.github.io/%20categories/%E7%B2%BE%E9%80%89/">精选</a></span>
        <span><a class="tag" href="https://gaoshanwomeng.github.io/%20tags/js/">js</a></span>
        
      </div>
    </div>

    <ul class="menu">
    <li class="menu-item">
        <a href="https://gaoshanwomeng.github.io/" id="back-btn">
            <i class="iconfont icon-home item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="back-top-btn">
            <i class="iconfont icon-top item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="switch-btn">
            <i class="iconfont icon-switch item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="search-btn">
            <i class="iconfont icon-search item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://gaoshanwomeng.github.io/post/vue-v-if%E5%A1%AB%E5%9D%91/" data-tooltip="vue v-if填坑">
            <i class="iconfont icon-left item-btn"></i>
            
        </a>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://gaoshanwomeng.github.io/post/js-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/" data-tooltip="js 循环遍历详解">
            <i class="iconfont icon-right item-btn"></i>
            
        </a>
    </li>
</ul>

  </div>
</div>

<div class="cover animated fadeInShow">
        <div class="search-container animated fadeInShow">
    <input type="search" class="docsearch-input search-input" placeholder="搜索关键词" />
    <div id="loading" class="loading-container">
        <span>搜索中...</span>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
    docsearch({
        apiKey: 'f7f9aeb8485880cfd0e747129ea4ddf9',
        indexName: 'blogsearch',
        appId: 'SGIZDO9IMB',
        inputSelector: '.docsearch-input',
        debug: true,
        algoliaOptions: {
            hitsPerPage: 50
        },
        
        
        
        queryHook: (query) => {
            $('#loading').css('display', 'flex');
        },
        transformData: (tips) => {
            $('#loading').css('display', 'none');
        }
    })
</script>
    </div>
</body>



<script type="text/javascript" src="https://gaoshanwomeng.github.io/js/util.min.801ba58b9554e77a2688843e942518db9f3bba50276845cc90afcd9fe5f4deac2c0fa3d1d918ec41dd1aea45a16b7782e09a365fe34d756db8d3bcacb3ccd3f4.js" integrity=""></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168042857-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</html>