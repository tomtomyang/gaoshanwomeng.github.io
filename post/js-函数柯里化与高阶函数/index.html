<!DOCTYPE html>
<html lang="zh-cn" data-theme="light"><head>
    <meta name="google-site-verification" content="kw1N-Xm6qEr1c9PGuRd0U_T6DXkw_EHsLyz5LpuDDv8" />
    <meta name="msvalidate.01" content="EE98205D30806C22C519683EFC53E9BA" />
    <meta name="baidu-site-verification" content="iPC3wUcQLL" />
    <title>  js 函数柯里化与高阶函数 </title>
    <meta charset="utf-8" /><meta name="generator" content="Hugo 0.85.0" /><meta name="viewport" content="width=device-width,initial-scale=1, minimum-scale=1, maximum-scale=1" />
    <meta name="description" itemprop="description"
        content=" js 函数柯里化与高阶函数 " />
    <meta name="keywords" itemprop="keywords"
        content=" [js 高阶函数 函数柯里化] " />
    <base href="https://gaoshanwomeng.github.io/">
    <link rel="shortcut icon" href="https://gaoshanwomeng.github.io/favicons//favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="32x32" href="https://gaoshanwomeng.github.io/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://gaoshanwomeng.github.io/favicons/favicon-16x16.png">
    <link rel="canonical" href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/">
    <link rel="stylesheet" type="text/css" href="https://at.alicdn.com/t/font_2450869_iypnqhtzjei.css">
    
    
    
    
    
    
    
    
    <link rel="stylesheet" href="https://gaoshanwomeng.github.io/css/style.min.50b2601e373617d56bada22a63c4678e95dc55c0ba89859ca0224f471279af33.css" integrity="" type="text/css">
</head><body>
<div class="main animated fadeInDown">
  <div class="toc sub-container">
    <div class="toc-header">
        <span>目录</span>
        <span id="read-percentage"></span>
    </div>
    <ul class="toc-h3"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#1-%e5%87%bd%e6%95%b0%e6%9f%af%e9%87%8c%e5%8c%96" class="toc-link">1. 函数柯里化</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#2-%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0" class="toc-link">2. 高阶函数</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#21-%e5%ae%9a%e4%b9%89" class="toc-link">2.1 定义</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#22-%e4%bd%9c%e7%94%a8" class="toc-link">2.2 作用</a>
                </li>
                
                        </ul><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#3-%e5%87%bd%e6%95%b0%e4%bd%9c%e4%b8%ba%e5%8f%82%e6%95%b0%e6%83%85%e5%86%b5" class="toc-link">3. 函数作为参数情况</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#31-arrayprototypemap" class="toc-link">3.1 Array.prototype.map</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#32-arrayprototypereduce" class="toc-link">3.2 Array.prototype.reduce</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#33-arrayprototypefilter" class="toc-link">3.3 Array.prototype.filter</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#34-arrayprototypesort" class="toc-link">3.4 Array.prototype.sort</a>
                </li>
                
                        <ul class="toc-h5"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#sort%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0" class="toc-link">sort排序算法的底层实现</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#%e5%a6%82%e4%bd%95%e6%94%b9%e8%bf%9b%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0%e6%95%b0%e5%ad%97%e6%ad%a3%e7%a1%ae%e6%8e%92%e5%ba%8f%e5%91%a2" class="toc-link">如何改进排序算法实现数字正确排序呢？</a>
                </li>
                
                        </ul>
                        </ul><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#4-%e5%87%bd%e6%95%b0%e4%bd%9c%e4%b8%ba%e8%bf%94%e5%9b%9e%e5%80%bc%e8%be%93%e5%87%ba" class="toc-link">4. 函数作为返回值输出</a>
                </li>
                
                        <ul class="toc-h4"><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#41-istype-%e5%87%bd%e6%95%b0" class="toc-link">4.1 isType 函数</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#42-add%e6%b1%82%e5%92%8c%e5%87%bd%e6%95%b0" class="toc-link">4.2 add求和函数</a>
                </li>
                <li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#43-%e8%87%aa%e5%b7%b1%e5%88%9b%e5%bb%ba%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0" class="toc-link">4.3 自己创建高阶函数</a>
                </li>
                
                        </ul><li>
                    <a href="https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/#5-%e6%80%bb%e7%bb%93" class="toc-link">5. 总结</a>
                </li>
                </div><div class="single-post container">
    <div class="post">
      <div class="header">
        <span class="title">js 函数柯里化与高阶函数</span>
        
        <div class="info">
          <span>📅 2021-03-26</span>
          <span>👦 Tomtom Young</span>
          <span>📖 4959字</span>
          <span>⏱ 10分钟</span>
        </div>
        
      </div>
      <div class="content markdown-body">
        <h3 id="1-函数柯里化">1. 函数柯里化</h3>
<p>函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。</p>
<h3 id="2-高阶函数">2. 高阶函数</h3>
<h4 id="21-定义">2.1 定义</h4>
<p>高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。</p>
<ol>
<li>若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。</li>
<li>若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。</li>
</ol>
<h4 id="22-作用">2.2 作用</h4>
<p>延迟执行</p>
<h3 id="3-函数作为参数情况">3. 函数作为参数情况</h3>
<p><code>Array.prototype.map</code>，<code>Array.prototype.filter</code>，<code>Array.prototype.reduce</code>和<code>Array.prototype.sort</code>是JavaScript中内置的高阶函数。它们接受一个函数作为参数，并应用这个函数到列表的每一个元素。下面是一些内置高阶函数的具体说明讲解，以及和不使用高阶函数情况下的对比：</p>
<h4 id="31-arrayprototypemap">3.1 Array.prototype.map</h4>
<p><code>map()</code>(映射)方法最后生成一个新数组，不改变原始数组的值。其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>array.map(callback,[ thisObject]);
</code></pre></div><p>callback(回调函数)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>[].map(<span style="color:#8be9fd;font-style:italic">function</span>(currentValue, index, array) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>    <span style="color:#6272a4">// ...
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#6272a4"></span>});
</code></pre></div><p>传递给 <code>map</code> 的回调函数（<code>callback</code>）接受三个参数，分别是<code>currentValue</code>——正在遍历的元素、index（可选）——元素索引、array（可选）——原数组本身，除了 <code>callback</code> 之外还可以接受 this 值（可选），用于执行 <code>callback</code> 函数时使用的this 值。</p>
<p>来个简单的例子方便理解，现在有一个数组<code>[1,2,3,4]</code>，我们想要生成一个新数组，其每个元素皆是之前数组的两倍，那么我们有下面两种使用高阶和不使用高阶函数的方式来实现。</p>
<p><strong>不使用高阶函数</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#6272a4">// koala
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> arr1 <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#ff79c6">const</span> arr2 <span style="color:#ff79c6">=</span> [];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd;font-style:italic">let</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> arr1.length; i<span style="color:#ff79c6">++</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>  arr2.push( arr1[i] <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>console.log( arr2 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#6272a4">// [2, 4, 6, 8]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#6272a4"></span>console.log( arr1 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#6272a4">// [1, 2, 3, 4]
</span></code></pre></div><p><strong>使用高阶函数</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#6272a4">// kaola
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> arr1 <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#ff79c6">const</span> arr2 <span style="color:#ff79c6">=</span> arr1.map(item =&gt; item <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>console.log( arr2 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span style="color:#6272a4">// [2, 4, 6, 8]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4"></span>console.log( arr1 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#6272a4">// [1, 2, 3, 4]
</span></code></pre></div><p><strong>map高阶函数注意点</strong></p>
<p>callback需要有return值，否则会出现所有项映射为undefind；</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#6272a4">// kaola
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> arr1 <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#ff79c6">const</span> arr2 <span style="color:#ff79c6">=</span> arr1.map(item =&gt; {});
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>console.log( arr2 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span style="color:#6272a4">// [ undefined, undefined, undefined, undefined ]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4"></span>console.log( arr1 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#6272a4">// [1, 2, 3, 4]
</span></code></pre></div><p><strong>map高阶函数对应的一道经典面试题</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#6272a4">//输出结果
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#6272a4"></span>[<span style="color:#f1fa8c">&#34;1&#34;</span>, <span style="color:#f1fa8c">&#34;2&#34;</span>, <span style="color:#f1fa8c">&#34;3&#34;</span>].map(<span style="color:#8be9fd;font-style:italic">parseInt</span>);
</code></pre></div><p>看了这道题不知道会不会有大多数开发者认为输出结果是[1,2,3]</p>
<p>正确的输出结果为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>[<span style="color:#bd93f9">1</span>,<span style="color:#ff79c6">NaN</span>,<span style="color:#ff79c6">NaN</span>]
</code></pre></div><p><strong>分析与讲解</strong></p>
<p>因为<code>map</code>的<code>callback</code>函数有三个参数，正在遍历的元素, 元素索引(index), 原数组本身(array)。<code>parseInt</code>有两个参数，string和radix(进制)，注意第二个参数进制当为0或者没有参数的时候，parseInt()会根据string来判断数字的基数。当忽略参数 radix , JavaScript 默认数字的基数如下:</p>
<ul>
<li>如果 string 以 &ldquo;0x&rdquo; 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。</li>
<li>如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。</li>
<li>如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。</li>
</ul>
<p>只传入parseInt的话，map callback会自动忽略第三个参数array。而index参数不会被忽略。而不被忽略的index(0,1,2)就会被parseInt当做第二个参数。</p>
<p>将其拆开看：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">parseInt</span>(<span style="color:#f1fa8c">&#34;1&#34;</span>,<span style="color:#bd93f9">0</span>);<span style="color:#6272a4">//上面说过第二个参数为进制，所以&#34;1&#34;，radix为0上面提到过，会忽略，根据string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数1。
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">parseInt</span>(<span style="color:#f1fa8c">&#34;2&#34;</span>,<span style="color:#bd93f9">1</span>);<span style="color:#6272a4">//此时将2转为1进制数，由于超过进制数1，所以返回NaN。
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">parseInt</span>(<span style="color:#f1fa8c">&#34;3&#34;</span>,<span style="color:#bd93f9">2</span>);<span style="color:#6272a4">//此时将3转为2进制数，由于超过进制数1，所以返回NaN。
</span></code></pre></div><p>所以最终的结果为<code>[1,NaN,NaN]</code>。</p>
<p>那么如果想要得到<code>[1,2,3]</code>该怎么写。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>[<span style="color:#f1fa8c">&#34;1&#34;</span>,<span style="color:#f1fa8c">&#34;2&#34;</span>,<span style="color:#f1fa8c">&#34;3&#34;</span>].map((x)=&gt;{
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">parseInt</span>(x);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>});
</code></pre></div><p>也可以简写为：
<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(x=&gt;parseInt(x));</code></p>
<p>这样写为什么就能返回想要的值呢？因为，传一个完整函数进去，有形参，有返回值。这样就不会造成因为参数传入错误而造成结果错误了，最后返回一个经纯函数处理过的新数组。</p>
<h4 id="32-arrayprototypereduce">3.2 Array.prototype.reduce</h4>
<p><code>reduce()</code> 方法对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。传递给 reduce 的回调函数（<code>callback</code>）接受四个参数，分别是累加器 <code>accumulator</code>、<code>currentValue</code>——正在操作的元素、<code>currentIndex</code>（可选）——元素索引，但是它的开始会有特殊说明、array（可选）——原始数组本身，除了 <code>callback</code> 之外还可以接受初始值 <code>initialValue</code> 值（可选）。</p>
<ul>
<li>如果没有提供 initialValue，那么第一次调用 callback 函数时，accumulator 使用原数组中的第一个元素，currentValue 即是数组中的第二个元素。 在没有初始值的空数组上调用 reduce 将报错。</li>
<li>如果提供了 initialValue，那么将作为第一次调用 callback 函数时的第一个参数的值，即 accumulator，currentValue 使用原数组中的第一个元素。</li>
</ul>
<p>例子，现在有一个数组 [0, 1, 2, 3, 4]，需要计算数组元素的和，需求比较简单，来看下代码实现。</p>
<p><strong>不使用高阶函数</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#6272a4">//koala
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> arr <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#8be9fd;font-style:italic">let</span> sum <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd;font-style:italic">let</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> arr.length; i<span style="color:#ff79c6">++</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>  sum <span style="color:#ff79c6">+=</span> arr[i];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>console.log( sum );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#6272a4">// 10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#6272a4"></span>console.log( arr );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#6272a4">// [0, 1, 2, 3, 4]
</span></code></pre></div><p><strong>使用高阶函数</strong></p>
<p>无 initialValue 值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#ff79c6">const</span> arr <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">let</span> sum <span style="color:#ff79c6">=</span> arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>  <span style="color:#ff79c6">return</span> accumulator <span style="color:#ff79c6">+</span> currentValue;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>});
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>console.log( sum );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4">// 10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#6272a4"></span>console.log( arr );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span><span style="color:#6272a4">// [0, 1, 2, 3, 4]
</span></code></pre></div><p>上面是没有 initialValue 的情况，代码的执行过程如下，callback 总共调用四次。</p>
<table>
<thead>
<tr>
<th>callback</th>
<th>accumulator</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody>
<tr>
<td>first call</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>[0, 1, 2, 3, 4]</td>
<td>1</td>
</tr>
<tr>
<td>second call</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>[0, 1, 2, 3, 4]</td>
<td>3</td>
</tr>
<tr>
<td>third call</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>[0, 1, 2, 3, 4]</td>
<td>6</td>
</tr>
<tr>
<td>fourth call</td>
<td>6</td>
<td>4</td>
<td>4</td>
<td>[0, 1, 2, 3, 4]</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>有 initialValue 值</p>
<p>我们再来看下有 initialValue 的情况，假设 initialValue 值为 10，我们看下代码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#6272a4">//koala
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#6272a4"></span><span style="color:#ff79c6">const</span> arr <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#8be9fd;font-style:italic">let</span> sum <span style="color:#ff79c6">=</span> arr.reduce((accumulator, currentValue, currentIndex, array) =&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>  <span style="color:#ff79c6">return</span> accumulator <span style="color:#ff79c6">+</span> currentValue;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>}, <span style="color:#bd93f9">10</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>console.log( sum );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#6272a4">// 20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#6272a4"></span>console.log( arr );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#6272a4">// [0, 1, 2, 3, 4]
</span></code></pre></div><p>代码的执行过程如下所示，callback 总共调用五次。</p>
<table>
<thead>
<tr>
<th>callback</th>
<th>accumulator</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody>
<tr>
<td>first call</td>
<td>10</td>
<td>0</td>
<td>0</td>
<td>[0, 1, 2, 3, 4]</td>
<td>10</td>
</tr>
<tr>
<td>second call</td>
<td>10</td>
<td>1</td>
<td>1</td>
<td>[0, 1, 2, 3, 4]</td>
<td>11</td>
</tr>
<tr>
<td>third call</td>
<td>11</td>
<td>2</td>
<td>2</td>
<td>[0, 1, 2, 3, 4]</td>
<td>13</td>
</tr>
<tr>
<td>fourth call</td>
<td>13</td>
<td>3</td>
<td>3</td>
<td>[0, 1, 2, 3, 4]</td>
<td>16</td>
</tr>
<tr>
<td>fifth call</td>
<td>16</td>
<td>4</td>
<td>4</td>
<td>[0, 1, 2, 3, 4]</td>
<td>20</td>
</tr>
</tbody>
</table>
<h4 id="33-arrayprototypefilter">3.3 Array.prototype.filter</h4>
<p><code>filter</code>(过滤，筛选) 方法创建一个新数组,原始数组不发生改变。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>array.filter(callback,[ thisObject]);
</code></pre></div><p>其包含通过提供函数实现的测试的所有元素。接收的参数和 map 是一样的，filter的<code>callbac</code>k函数需要返回布尔值true或false. 如果为true则表示通过啦！如果为false则失败，其返回值是一个新数组，由通过测试为true的所有元素组成，如果没有任何数组元素通过测试，则返回空数组。</p>
<p>来个例子介绍下，现在有一个数组 <code>[1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]</code>，我们想要生成一个新数组，这个数组要求没有重复的内容，即为去重。</p>
<p><strong>不使用高阶函数</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#ff79c6">const</span> arr1 <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">5</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">5</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#ff79c6">const</span> arr2 <span style="color:#ff79c6">=</span> [];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#ff79c6">for</span> (<span style="color:#8be9fd;font-style:italic">let</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">&lt;</span> arr1.length; i<span style="color:#ff79c6">++</span>) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>  <span style="color:#ff79c6">if</span> (arr1.indexOf( arr1[i] ) <span style="color:#ff79c6">===</span> i) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>    arr2.push( arr1[i] );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>  }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>console.log( arr2 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#6272a4">// [1, 2, 3, 5, 4]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#6272a4"></span>console.log( arr1 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#6272a4">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
</span></code></pre></div><p><strong>使用高阶函数</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#ff79c6">const</span> arr1 <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">5</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">5</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">4</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#ff79c6">const</span> arr2 <span style="color:#ff79c6">=</span> arr1.filter( (element, index, self) =&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>    <span style="color:#ff79c6">return</span> self.indexOf( element ) <span style="color:#ff79c6">===</span> index;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>});
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>console.log( arr2 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4">// [1, 2, 3, 5, 4]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span style="color:#6272a4"></span>console.log( arr1 );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span><span style="color:#6272a4">// [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4]
</span></code></pre></div><p><strong>filter注意点说明</strong></p>
<p><code>callback</code>在过滤测试的时候，一定要是Boolean值吗？
例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">var</span> arr <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#8be9fd;font-style:italic">var</span> arrayFilter <span style="color:#ff79c6">=</span> arr.filter(<span style="color:#8be9fd;font-style:italic">function</span>(item) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>    <span style="color:#ff79c6">return</span> item;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>});
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>console.log(arrayFilter); <span style="color:#6272a4">// [1, 2, 3]
</span></code></pre></div><p>通过例子可以看出:过滤测试的返回值只要是弱等于== true/false就可以了，而非非得返回 === true/false.</p>
<h4 id="34-arrayprototypesort">3.4 Array.prototype.sort</h4>
<p><code>sort() </code>方法用原地算法对数组的元素进行排序，并返回数组，该排序方法会在原数组上直接进行排序，并不会生成一个排好序的新数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#6272a4">// 语法
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#6272a4"></span>arr.sort([compareFunction])
</code></pre></div><p><code>compareFunction</code>参数是可选的，用来指定按某种顺序进行排列的函数。注意该函数有两个参数：</p>
<p><strong>参数1:firstEl</strong></p>
<p>第一个用于比较的元素。</p>
<p><strong>参数2:secondEl</strong></p>
<p>第二个用于比较的元素。看下面的例子与说明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#6272a4">// 未指明compareFunction函数
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#6272a4"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>[<span style="color:#f1fa8c">&#39;Google&#39;</span>, <span style="color:#f1fa8c">&#39;Apple&#39;</span>, <span style="color:#f1fa8c">&#39;Microsoft&#39;</span>].sort(); <span style="color:#6272a4">// [&#39;Apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;];
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#6272a4"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#6272a4">// apple排在了最后:
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#6272a4"></span>[<span style="color:#f1fa8c">&#39;Google&#39;</span>, <span style="color:#f1fa8c">&#39;apple&#39;</span>, <span style="color:#f1fa8c">&#39;Microsoft&#39;</span>].sort(); <span style="color:#6272a4">// [&#39;Google&#39;, &#39;Microsoft&#34;, &#39;apple&#39;]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#6272a4"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#6272a4">// 无法理解的结果:
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#6272a4"></span>[<span style="color:#bd93f9">10</span>, <span style="color:#bd93f9">20</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>].sort(); <span style="color:#6272a4">// [1, 10, 2, 20]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#6272a4">//正确的结果
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#6272a4"></span>[<span style="color:#bd93f9">6</span>, <span style="color:#bd93f9">8</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>].sort(); <span style="color:#6272a4">// [1, 2，6, 8]
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span style="color:#6272a4"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span style="color:#6272a4">// 指明compareFunction函数
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span style="color:#6272a4"></span><span style="color:#f1fa8c">&#39;use strict&#39;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span style="color:#8be9fd;font-style:italic">var</span> arr <span style="color:#ff79c6">=</span> [<span style="color:#bd93f9">10</span>, <span style="color:#bd93f9">20</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>    arr.sort(<span style="color:#8be9fd;font-style:italic">function</span> (x, y) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>        <span style="color:#ff79c6">if</span> (x <span style="color:#ff79c6">&lt;</span> y) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>        <span style="color:#ff79c6">if</span> (x <span style="color:#ff79c6">&gt;</span> y) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span>            <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span>        <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span>    });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span>console.log(arr); <span style="color:#6272a4">// [1, 2, 10, 20]
</span></code></pre></div><p>如果没有指明 <code>compareFunction</code> ，那么元素会按照转换为的字符串的诸个字符的<code>Unicode</code>位点进行排序。例如 &ldquo;Banana&rdquo; 会被排列到 &ldquo;cherry&rdquo; 之前。当数字按由小到大排序时，10 出现在 2 之前，但因为（没有指明 <code>compareFunction</code>），比较的数字会先被转换为字符串，所以在<code>Unicode</code>顺序上 &ldquo;10&rdquo; 要比 &ldquo;2&rdquo; 要靠前。</p>
<p>如果指明了 <code>compareFunction</code> ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：</p>
<ul>
<li>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</li>
<li>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</li>
<li>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</li>
</ul>
<p>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</p>
<h5 id="sort排序算法的底层实现">sort排序算法的底层实现</h5>
<p>看了上面<code>sort</code>的排序介绍，我想小伙伴们肯定会对sort排序算法的内部实现感兴趣，我在sf上面搜了一下，发现有些争议。于是去查看了V8引擎的源码，发现在源码中的710行</p>
<blockquote>
<p>源码地址：<a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js">https://github.com/v8/v8/blob&hellip;</a></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#6272a4">// In-place QuickSort algorithm.
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#6272a4">// For short (length &lt;= 22) arrays, insertion sort is used for efficiency.
</span></code></pre></div><p>V8 引擎 sort 函数只给出了两种排序 <code>InsertionSort</code>和 <code>QuickSort</code>，<strong>数量小于等于22</strong>的数组使用 <code>InsertionSort</code>，比22大的数组则使用 <code>QuickSort</code>，有兴趣的可以看看具体算法实现。</p>
<blockquote>
<p>注意：不同的浏览器引擎可能算法实现并不同，我这里只是查看了V8引擎的算法实现，有兴趣的小伙伴可以查看下其他开源浏览器具体sort的算法实现。</p>
</blockquote>
<h5 id="如何改进排序算法实现数字正确排序呢">如何改进排序算法实现数字正确排序呢？</h5>
<p>对于要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列，降序排序则使用b-a。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">let</span> compareNumbers<span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span> (a, b) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>    <span style="color:#ff79c6">return</span> a <span style="color:#ff79c6">-</span> b;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span style="color:#8be9fd;font-style:italic">let</span> koala<span style="color:#ff79c6">=</span>[<span style="color:#bd93f9">10</span>, <span style="color:#bd93f9">20</span>, <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>].sort(compareNumbers)
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>console.log(koala);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4">// [1 , 2 , 10 , 20]
</span></code></pre></div><h3 id="4-函数作为返回值输出">4. 函数作为返回值输出</h3>
<p>返回一个函数，下面直接看两个例子来加深理解。</p>
<h4 id="41-istype-函数">4.1 isType 函数</h4>
<p>我们知道在判断类型的时候可以通过<code>Object.prototype.toString.call</code> 来获取对应对象返回的字符串，比如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">let</span> isString <span style="color:#ff79c6">=</span> obj =&gt; <span style="color:#8be9fd;font-style:italic">Object</span>.prototype.toString.call( obj ) <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;[object String]&#39;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#8be9fd;font-style:italic">let</span> isArray <span style="color:#ff79c6">=</span> obj =&gt; <span style="color:#8be9fd;font-style:italic">Object</span>.prototype.toString.call( obj ) <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;[object Array]&#39;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span style="color:#8be9fd;font-style:italic">let</span> isNumber <span style="color:#ff79c6">=</span> obj =&gt; <span style="color:#8be9fd;font-style:italic">Object</span>.prototype.toString.call( obj ) <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;[object Number]&#39;</span>;
</code></pre></div><p>可以发现上面三行代码有很多重复代码，只需要把具体的类型抽离出来就可以封装成一个判断类型的方法了，代码如下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#8be9fd;font-style:italic">let</span> isType <span style="color:#ff79c6">=</span> type =&gt; obj =&gt; {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>  <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">Object</span>.prototype.toString.call( obj ) <span style="color:#ff79c6">===</span> <span style="color:#f1fa8c">&#39;[object &#39;</span> <span style="color:#ff79c6">+</span> type <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#39;]&#39;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>isType(<span style="color:#f1fa8c">&#39;String&#39;</span>)(<span style="color:#f1fa8c">&#39;123&#39;</span>);        <span style="color:#6272a4">// true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span style="color:#6272a4"></span>isType(<span style="color:#f1fa8c">&#39;Array&#39;</span>)([<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>]);    <span style="color:#6272a4">// true
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span style="color:#6272a4"></span>isType(<span style="color:#f1fa8c">&#39;Number&#39;</span>)(<span style="color:#bd93f9">123</span>);            <span style="color:#6272a4">// true
</span></code></pre></div><p>这里就是一个高阶函数，因为 isType 函数将 <code>obj =&gt; { ... }</code> 这一函数作为返回值输出。</p>
<h4 id="42-add求和函数">4.2 add求和函数</h4>
<p>前言中的面试题，用 JS 实现一个无限累加的函数 add，示例如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>add(<span style="color:#bd93f9">1</span>); <span style="color:#6272a4">// 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span style="color:#6272a4"></span>add(<span style="color:#bd93f9">1</span>)(<span style="color:#bd93f9">2</span>);  <span style="color:#6272a4">// 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span style="color:#6272a4"></span>add(<span style="color:#bd93f9">1</span>)(<span style="color:#bd93f9">2</span>)(<span style="color:#bd93f9">3</span>)； <span style="color:#6272a4">// 6
</span></code></pre></div><p>分析面试题的结构，都是将函数作为返回值输出，然后接收新的参数并进行计算。</p>
<p>我们知道打印函数时会自动调用 <code>toString()</code>方法（如果不知道的可以去看我的这篇文章），函数 add(a) 返回一个sum(b)函数，函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回变量 a 就可以了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#8be9fd;font-style:italic">function</span> add(a) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>    <span style="color:#8be9fd;font-style:italic">function</span> sum(b) { <span style="color:#6272a4">// 使用闭包
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#6272a4"></span>        a <span style="color:#ff79c6">=</span> a <span style="color:#ff79c6">+</span> b; <span style="color:#6272a4">// 累加
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> sum;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>     }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>     sum.toString <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">function</span>() { <span style="color:#6272a4">// 重写toString()方法
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> a;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>     <span style="color:#ff79c6">return</span> sum; <span style="color:#6272a4">// 返回一个函数
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span style="color:#6272a4"></span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>add(<span style="color:#bd93f9">1</span>); <span style="color:#6272a4">// 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span style="color:#6272a4"></span>add(<span style="color:#bd93f9">1</span>)(<span style="color:#bd93f9">2</span>);  <span style="color:#6272a4">// 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span style="color:#6272a4"></span>add(<span style="color:#bd93f9">1</span>)(<span style="color:#bd93f9">2</span>)(<span style="color:#bd93f9">3</span>)； <span style="color:#6272a4">// 6
</span></code></pre></div><h4 id="43-自己创建高阶函数">4.3 自己创建高阶函数</h4>
<p>前面讲了语言中内置的各种高阶函数。知道了到底啊什么是高阶函数，有哪些类型的高阶函数。那么让我们<strong>自己创建一个高阶函数吧！</strong></p>
<p>假设 JavaScript 没有原生的<code>map</code>方法。 我们自己构建个类似map的高阶函数，从而创建我们自己的高阶函数。
假设我们有一个字符串数组，我们希望把它转换为整数数组，其中每个元素代表原始数组中字符串的长度。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#ff79c6">const</span> strArray<span style="color:#ff79c6">=</span>[<span style="color:#f1fa8c">&#39;JavaScript&#39;</span>,<span style="color:#f1fa8c">&#39;PHP&#39;</span>,<span style="color:#f1fa8c">&#39;JAVA&#39;</span>,<span style="color:#f1fa8c">&#39;C&#39;</span>,<span style="color:#f1fa8c">&#39;Python&#39;</span>];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#8be9fd;font-style:italic">function</span> mapForEach(arr,fn){
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>    <span style="color:#ff79c6">const</span> newArray <span style="color:#ff79c6">=</span> [];
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>    <span style="color:#ff79c6">for</span>(<span style="color:#8be9fd;font-style:italic">let</span> i <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; i<span style="color:#ff79c6">&lt;</span>arr.length;i<span style="color:#ff79c6">++</span>){
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>        newArray.push({
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>            fn(arr[i])
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>        );
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>    <span style="color:#ff79c6">return</span> newArray;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span style="color:#ff79c6">const</span> lenArray <span style="color:#ff79c6">=</span> mapForEach(strArray,<span style="color:#8be9fd;font-style:italic">function</span>(item){
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>    <span style="color:#ff79c6">return</span> item.length;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>});
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>console.log(lenArray);<span style="color:#6272a4">//[10,3,4,1,6]
</span></code></pre></div><p><strong>代码分析讲解：</strong></p>
<p>我们创建了一个高阶函数 mapForEach ，它接受一个数组和一个回调函数 fn。 它循环遍历传入的数组，并在每次迭代时在 newArray.push 方法调用回调函数 fn 。</p>
<p>回调函数 fn 接收数组的当前元素并返回该元素的长度，该元素存储在 newArray 中。 for 循环完成后，newArray 被返回并赋值给 lenArray。</p>
<h3 id="5-总结">5. 总结</h3>
<p>我们已经了解了高阶函数和一些内置的高阶函数，还学习了如何创建自己的高阶函数。</p>
<p>简而言之，高阶函数是一个可以接收函数作为参数，甚至返回一个函数的函数。 它就像常规函数一样，只是多了接收和返回其他函数的附加能力，即参数和输出，js中的回调的概念就是基于函数柯里化与高阶函数实现的。</p>

      </div>
      <div class="footer">
        <span><a class="category" href="https://gaoshanwomeng.github.io/%20categories/%E5%89%8D%E7%AB%AF/">前端</a></span>
        <span><a class="tag" href="https://gaoshanwomeng.github.io/%20tags/js/">js</a></span>
        
      </div>
    </div>

    <ul class="menu">
    <li class="menu-item">
        <a href="https://gaoshanwomeng.github.io/" id="back-btn">
            <i class="iconfont icon-home item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="back-top-btn">
            <i class="iconfont icon-top item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="switch-btn">
            <i class="iconfont icon-switch item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        <a href="javascript:void(0);" id="search-btn">
            <i class="iconfont icon-search item-btn"></i>
        </a>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://gaoshanwomeng.github.io/post/es6-%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95/" data-tooltip="es6 数值扩展">
            <i class="iconfont icon-left item-btn"></i>
            
        </a>
    </li>
    <li class="menu-item">
        
        <a class="" href="https://gaoshanwomeng.github.io/post/import-reactcomponent-from-react%E8%A7%A3%E9%87%8A/" data-tooltip="import React,{Component} from &#39;react&#39;解释">
            <i class="iconfont icon-right item-btn"></i>
            
        </a>
    </li>
</ul>

  </div>
</div>

<div class="cover animated fadeInShow">
        <div class="search-container animated fadeInShow">
    <input type="search" class="docsearch-input search-input" placeholder="搜索关键词" />
    <div id="loading" class="loading-container">
        <span>搜索中...</span>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
    docsearch({
        apiKey: 'f7f9aeb8485880cfd0e747129ea4ddf9',
        indexName: 'blogsearch',
        appId: 'SGIZDO9IMB',
        inputSelector: '.docsearch-input',
        debug: true,
        algoliaOptions: {
            hitsPerPage: 50
        },
        
        
        
        queryHook: (query) => {
            $('#loading').css('display', 'flex');
        },
        transformData: (tips) => {
            $('#loading').css('display', 'none');
        }
    })
</script>
    </div>
</body>



<script type="text/javascript" src="https://gaoshanwomeng.github.io/js/util.min.801ba58b9554e77a2688843e942518db9f3bba50276845cc90afcd9fe5f4deac2c0fa3d1d918ec41dd1aea45a16b7782e09a365fe34d756db8d3bcacb3ccd3f4.js" integrity=""></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-168042857-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</html>