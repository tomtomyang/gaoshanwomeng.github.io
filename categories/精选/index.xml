<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>精选 on TomtomYoung Blog 🧐</title>
    <link>https://tomtomyoung.top/categories/%E7%B2%BE%E9%80%89/</link>
    <description>Recent content in 精选 on TomtomYoung Blog 🧐</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 24 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://tomtomyoung.top/categories/%E7%B2%BE%E9%80%89/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-async%E4%B8%8Eawait%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 24 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-async%E4%B8%8Eawait%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： async 和 await:让异步编程更简单 1. async 首先，我们使用 async 关键字，把它放在函数声明之前，使其成为 async function 。异步函数是一个知道怎样使用 await 关键字调用异步代码的函数。 2. await 3. generator</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/react-fiber%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/react-fiber%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 走进 React Fiber 的世界 手写 React 的 Fiber 架构，深入理解其原理 1. 背景 在之前的《react react 时间切片与 requestIdleCallback 详解》中，我们了解到 React 为了解决浏览器性能瓶颈，提出了时间切片的机制，将大任务拆分为小任务分别执行。 那么我们就不</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/react-%E6%89%8B%E5%86%99react16.x%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/react-%E6%89%8B%E5%86%99react16.x%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/</guid>
      <description>参考： 8 月更文挑战｜react 手写实现渲染 JSX 普通版 手写一个简单的 React 手写一个 react 系列（一）：实现 react 和 react-dom 手写 react 核心源码 面试装不了逼？当场手写个 react16.x 框架给他看看 1. 搭建项目 1. 初始化项目 我们需要初始化一个空的 webpack 项目</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/react-%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87%E4%B8%8Erequestidlecallback%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/react-%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87%E4%B8%8Erequestidlecallback%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 走进 React Fiber 的世界 1. 浏览器性能瓶颈 我们日常使用 App，浏览网页时，有两类场景会制约快速响应： 当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。 发送网络请求后，由于需要等待数据返回才能进一步操</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/react-jsx%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/react-jsx%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： react 中文文档_JSX 简介 React 之技术详解（三）- 深入理解 JSX 手写 react 核心源码 配置 babel-loader 处理 JSX 语法 1. 什么是 JSX 设想如下变量声明： 1const element = &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;; 这个语法既不是字符串也不是 HTML，而是 React 独有的 JSX 语法。 JSX 全程是 JavaScript XML，</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/react_native-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/react_native-%E7%AE%80%E4%BB%8B/</guid>
      <description>参考： React Native 中文网 React Native 介绍 深入理解 react-native Metro_Docs react-native metro 分析 react-native bundle 到 bundle 生成到底发生了什么(metro 打包流程简析) JavaScriptCore 深入浅出 JavaScriptCore React Native、React 和 JavascriptCore 的关系 1. React Native 1. 定义 要了解 RN，肯定是要从官网入手： 按照官网的介</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/vue-%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/vue-%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</guid>
      <description>参考： Vue.js_深入响应式原理 Vue 源码分析之实现一个简易版的 Vue DMQ/mvvm vue 源码解读（一）Observer/Dep/Watcher 是如何实现数据绑定的 Observer、Dep、Watcher 傻傻搞不清楚 1. 双向</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/vue-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/vue-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： Vue.js_深入响应式原理 Vue 源码分析之实现一个简易版的 Vue DMQ/mvvm 1. 数据劫持原理 关于如何实现数据劫持，在 Vue 的官网有一段描述： Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/mvc%E4%B8%8Emvvm%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/mvc%E4%B8%8Emvvm%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MVC，MVP 和 MVVM 的图示 浅谈 MVC、MVP 和 MVVM 架构模式 架构模式：MVC 与 MVVM 结合 vue、react、angular 谈谈 MVC、MVP、MVVM 框架 1. 架构模式 MVC 和 MVVM 都是架构模式！ MVC 描述了「Model</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_JavaScript 中的继承 js 继承的几种方式 Javascript 继承机制的设计思想 Javascript – How Prototypal Inheritance really works javascript 中实现继承的六种方式 ES6 里 Class 的 Extends 继承原理 有些人认为 JavaScript 并不是真正的面向对象语言，在经典的面向对象语言中，您可能倾向于定义类对象，然后您可</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 浅谈浏览器渲染、回流和重绘 渲染树构建、布局及绘制 尽可能减少浏览器重排 1. 页面渲染 根据《浏览器 页面渲染详解》，我们可以知道浏览器渲染页面分为以下几步： 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 渲染树构建、布局及绘制 构建对象模型 浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。 1. DOM 字节 → 字符 → 令牌 → 节点 → 对象模型。 HTML 标记转换成文档对象模型 (DOM)；CS</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： js 对象(一)——创建对象 js 对象（二）—— 函数与对象的关系（认识原型链） 一张图搞定 JS 原型&amp;amp;原型链 js 的初学者一般很难理解原型和原型链的概念，但原型和原型链又是 js 中最重要的点之一，关系到对 js 所</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-es6_module%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-es6_module%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： ES6 module 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 im</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-this%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-this%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_this JavaScript 的 this 原理 彻底理解 js 中 this 的指向，不必硬背。 1. 定义 this 与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在 严格模式 和非严格模式之间也会有一些差别。 在绝大多数情况下，函数的调用方式决定了 this 的</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-umd%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-umd%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： umd.js 可能是最详细的 UMD 模块入门指南 1. UMD 因为有像 CommonJS、AMD、CMD 等不同的规范，导致了 js 实现模块化有很多方式，那有没有一种方式可以屏蔽掉这种不同，让我们不去思考使用什么模块化规范，专心的</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 前端模块化：CommonJS,AMD,CMD,ES6 wikipedia_CommonJS 深入浅出 Node.js 前端科普系列-CommonJS：不是前端却革命了前端 从 CommonJS 到 Sea.js CommonJS wiki mozillaWiki_ServerJS 《编程时间简史系列》JavaScript 模块化的历史进程 Node.js_CommonJS modules RequireJS 和</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_闭包 你不懂 JS：作用域与闭包 学习 Javascript 闭包（Closure） 在 JavaScript 中闭包无所不在，你必须识别并接纳它。 闭包是词法作用域导致的结果。闭包在你的代码中一直在被创建和使用，你在毫无意识的状态下就使用</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-letconst%E4%B8%8E%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-letconst%E4%B8%8E%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>参考： MDN_let 为什么在 JavaScript 中为块范围变量声明选择名称“let”？ let 深入理解&amp;mdash;let 存在变量提升吗？ 我用了两个月的时间才理解 let JS 变量封禁大法：薛定谔的 X let 声明会提升（hoist）吗？ 1. 作用域对 var 的处</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</guid>
      <description>参考： MDN Scope 深入理解 javascript 作用域系列第一篇——内部原理 深入理解 javascript 作用域系列第二篇——词法作用域和动态作用域 你不懂 JS：作用域与闭包 let, const 和块级作用域 1. 作用域 第一种说法： javascript 拥有一套设计良好的规则来存储变量，并且</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 维基百科_同源策略 浏览器同源政策及其规避方法 MDN_浏览器的同源策略 web_dev_同源策略 1. 同源策略 1. 什么是源 两个 URL 的 protocol、port (如果有指定的话)和 host 组成了源。这个方案也被称为</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN HTTP/Caching MDN Cache-Control MDN Expires MDN ETag MDN If-None-Match 彻底弄懂 HTTP 缓存机制及原理 5 分钟看懂系列：HTTP 缓存机制详解 1. 什么是 HTTP 缓存 通过复用以前获取的资源，可以显著提高网站和应用程序的性能。 HTTP 缓存减少了等待时间和网络流量，因此减少了</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN http 1. HTTP HTTP (HyperText Transfer Protocol)，即超文本传输协议，是实现网络通信的一种规范。 1. HTTP 报文 HTTP 消息是服务器和客户端之间交换数据的方式。有两种类型的消息︰ 请求（requests）&amp;ndash;由客户端发</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E8%AE%A1%E7%AE%97%E8%AE%A1%E7%BD%91%E7%BB%9C-%E5%9F%9F%E5%90%8D%E4%B8%8Edns%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E8%AE%A1%E7%AE%97%E8%AE%A1%E7%BD%91%E7%BB%9C-%E5%9F%9F%E5%90%8D%E4%B8%8Edns%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN DNS DNS 原理入门 what-is-dns 工程师最容易搞错的域名知识 域名层级划分 域名分级与域名解析过程(DNS) 1. 域名 1. 域名的层级 根域名 .root 对于所有域名都是一样的，所以平时是省略的； 根服务器主要用来管理互联网的主目录； 全世</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0promise/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0promise/</guid>
      <description>1. 简易版 Promise 1. 实现 executor 比如我们实例化一个 Promise 对象时，会这样写： 1let p1 = new Promise((resolve, reject) =&amp;gt; { 2 resolve(12345); 3}) 这里要注意的是： constructor 接收一个函数作为参数； 这个传入的函数会在实例化时（执行构造函数时）立即执行； 传入的函数接收两个函数（re</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-xsscsrf/</link>
      <pubDate>Wed, 14 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-xsscsrf/</guid>
      <description>1：什么是 XSS 攻击？ XSS，即 Cross Site Script，跨站脚本攻击； XSS 攻击是指攻击者在网站上注入恶意的客户端代码，对客户端网页进行篡改，对用户浏览器进行控制或者获取用户隐私数据； XSS 攻击可以分为 3 类：反射型（非</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Promise 定义 promise A+ A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled. promise 表示异步操作的最终结果。与 promise 交互的主要方式是通过它的 then 方法，该方法注册回调来接收 promise 的最</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-settimeoutsetinterval/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-settimeoutsetinterval/</guid>
      <description>1. setTimeout setTimeout 的在一段时间之后，执行指定的一段函数 （仅执行一次） 可以理解为指定延迟后执行函数 2. setInterval setInterval 是循环执行函数，每隔一段时间就执行一次指定的函数（执行 N 次） 可以理解为指定周期执行函数 3. 两者区别 两个函数的另一</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</guid>
      <description>参考： The JavaScript Event Loop: Explained ES2015(ES6) MDN_并发模型与事件循环 MDN_深入：微任务和 JavaScript 运行时环境 MDN_在 JavaScript 中通过 queueMicrotask() 使用微任务 Node.js_event_loop WHATWG 规范_event_loop JavaScript Info_event-loop 宏任务和微任务到底是什么？ JavaScript 运行机制详解：再谈 Event Loop 事件循环</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/git-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/git-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</guid>
      <description>切换到你的线上分支（production branch）。 为这个紧急任务新建一个分支，并在其中修复它。 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 切换回你最初工作的分</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/git-%E5%AE%B6%E6%97%8F%E5%BC%8F%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/git-%E5%AE%B6%E6%97%8F%E5%BC%8F%E5%91%BD%E4%BB%A4/</guid>
      <description>1. 仓库操作 1. 初始化配置 1git config -global user.name &amp;lt;name&amp;gt; #设置提交者名字 2git config -global user.email &amp;lt;email&amp;gt; #设置提交者邮箱 3git config -global core.editor &amp;lt;editor&amp;gt; #设置默认文本编辑器 4git config -global merge.tool &amp;lt;tool&amp;gt; #设置解决合并冲突时差异分析工具 5git config -list #检查已有的配置信息 2. 创建本地仓库 1git init #初始化本</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</guid>
      <description>1. 克隆远程仓库到本地 Git 的 clone 命令会为你自动将远程主机命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。同时 Git 也会给你一个与 origin 的 master 分支在指</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 场景 下面这个面试题你大概率遇到过： 1for (var i = 0; i &amp;lt; 5; i++) { 2 setTimeout(() =&amp;gt; { 3 console.log(i); 4 }, 10); 5} 这里 var 会声明一个全局变量 i。函数会在 10 毫秒后异步执行，当函数在执行时，根据作用域链会在全局变量对象中进行查找，而此时循环已经</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 进程与线程 windows 打开任务管理器，可以看到后台进程列表。可以看到每个进程的内存资源信息以及 cpu 占有率。 所以，应该更容易理解了：进程是 cpu 资源分配的最小单位（系统会给它分配内存） 最后，再用较为官方的术语描述一遍</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 为什么使用 webpack 1. 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方法： 引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载大量脚本会导致网络瓶颈。 使用一个包含所有项目代</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/css-vhvw/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/css-vhvw/</guid>
      <description>1. vw vh 的介绍 vw,vh 是 css3 中给我们提供的新的单位，他们是相对于 viewport 视窗的宽高进行计算的单位。说白了，就是相对于浏览器的窗口的大小。 vw : 1vw 等于视口宽度的 1% vh : 1vh 等于视口高度的 1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的&amp;quot;hello&amp;quot;这个子串。 1var regex = /hello/; 2console.log( regex.test(&amp;#34;hello&amp;#34;) ); 正则表达式之所以强大，是因为其能实现模糊匹配。 而模糊</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/ssrcsr/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ssrcsr/</guid>
      <description>1. SSR 和 CSR 的概念 SSR(Server Side Rendering)： SSR 是传统的渲染方式，由服务端把渲染好的完整的页面发送给客户端。客户端拿到的是完整的页面，可以直接展示。前后端分离之前很长的一段时间里都是以服务端渲染为主（ASP</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/ajax-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ajax-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/</guid>
      <description>1.什么是预检请求 定义：预检请求（Preflighted requests ）是浏览器发起跨域请求时，通过 OPTIONS 方法询问服务器对跨域请求的支持情况（支持的包含请求方法、请求头、数据类型）。 2.什么时候会触发预检请求 请求会划</description>
    </item>
    
  </channel>
</rss>
