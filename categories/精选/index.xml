<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>精选 on TomtomYoung Blog</title>
    <link>https://gaoshanwomeng.github.io/categories/%E7%B2%BE%E9%80%89/</link>
    <description>Recent content in 精选 on TomtomYoung Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 02 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://gaoshanwomeng.github.io/categories/%E7%B2%BE%E9%80%89/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>js jsonp详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-jsonp%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-jsonp%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 同源策略和域 关于什么是浏览器的同源策略，什么是域，可以查看本站另一篇文章：浏览器 同源策略详解</description>
    </item>
    
    <item>
      <title>浏览器 同源策略详解</title>
      <link>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 维基百科_同源策略 浏览器同源政策及其规避方法 MDN_浏览器的同源策略 web_dev_同源策略 1. 同源策略 1. 什么是源 两个 URL 的 protocol、port (如果有指定的话)和 host组成了源。这个方案也</description>
    </item>
    
    <item>
      <title>js 手写promise</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E6%89%8B%E5%86%99promise/</link>
      <pubDate>Thu, 29 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E6%89%8B%E5%86%99promise/</guid>
      <description>参考： 手写Promise - 实现一个基础的Promise 面试官：“你能手写一个 Promise 吗” 1. 简易版Promise 1. 实现executor promise是一个类，它的构造函数接受一个函数，函数的两个参数也都是函数</description>
    </item>
    
    <item>
      <title>js map详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-map%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-map%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. map 定义 MDN map Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。 map和object的对比 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（</description>
    </item>
    
    <item>
      <title>js 模块化详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 发展历程 在本站另一篇博客：webpack简介的第一个章节：为什么使用webpack中，我们介绍了js代码编写的不同阶段： 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方</description>
    </item>
    
    <item>
      <title>浏览器 xss&amp;csrf</title>
      <link>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-xsscsrf/</link>
      <pubDate>Wed, 14 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-xsscsrf/</guid>
      <description>1：什么是XSS攻击？ XSS，即 Cross Site Script，跨站脚本攻击； XSS 攻击是指攻击者在网站上注入恶意的客户端代码，对客户端网页进行篡改，对用户浏览器进行控制或者获取用户隐私数据； XSS攻击可以分为3类：反</description>
    </item>
    
    <item>
      <title>js promise详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-promise%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-promise%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Promise 定义 promise A+ A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled. promise表示异步操作的最终结果。与promise交互的主要方式是通过它的then方</description>
    </item>
    
    <item>
      <title>js 原型&amp;原型链&amp;继承</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</guid>
      <description>1. prototype 每个函数都有一个 prototype 属性 每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&amp;quot;继承&amp;quot;属性。 1 2 3 4 5</description>
    </item>
    
    <item>
      <title>js setTimeout&amp;setInterval</title>
      <link>https://gaoshanwomeng.github.io/post/js-settimeoutsetinterval/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-settimeoutsetinterval/</guid>
      <description>1. setTimeout setTimeout的在一段时间之后，执行指定的一段函数 （仅执行一次） 可以理解为指定延迟后执行函数 2. setInterval setInterval是循环执行函数，每隔一段时间就执行一次指定的函数（执行N次） 可以理解为指</description>
    </item>
    
    <item>
      <title>js 事件循环与异步并发</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</guid>
      <description>1. JS事件 The event loop is the secret behind JavaScript’s asynchronous programming. JS executes all operations on a single thread, but using a few smart data structures, gives us the illusion of multi-threading. The asynchronous behavior is not part of the JavaScript language itself, rather it is built on top of the core JavaScript language in the browser (or the programming environment) and accessed through the browser APIs. 事件循环是JavaScript异步编</description>
    </item>
    
    <item>
      <title>git 分支的新建与合并</title>
      <link>https://gaoshanwomeng.github.io/post/git-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/git-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6/</guid>
      <description>切换到你的线上分支（production branch）。 为这个紧急任务新建一个分支，并在其中修复它。 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 切换回你最初工作的分</description>
    </item>
    
    <item>
      <title>git 家族式命令</title>
      <link>https://gaoshanwomeng.github.io/post/git-%E5%AE%B6%E6%97%8F%E5%BC%8F%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/git-%E5%AE%B6%E6%97%8F%E5%BC%8F%E5%91%BD%E4%BB%A4/</guid>
      <description>1. 初始化配置 config 1 2 3 4 5 git config -global user.name &amp;lt;name&amp;gt; #设置提交者名字 git config -global user.email &amp;lt;email&amp;gt; #设置提交者邮箱 git config -global core.editor &amp;lt;editor&amp;gt; #设置默认文本编辑器 git config -global merge.tool &amp;lt;tool&amp;gt; #设置解决合并冲突时差异分析工具 git config -list #检查已有的配置信息 2. 创建本地仓库 init 1 git init #初</description>
    </item>
    
    <item>
      <title>git 远程仓库与本地仓库</title>
      <link>https://gaoshanwomeng.github.io/post/git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/git-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8E%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</guid>
      <description>1. 从远程主机克隆 Git 的 clone 命令会为你自动将远程主机命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。同时Git 也会给你一个与 origin 的maste</description>
    </item>
    
    <item>
      <title>js IIFE简介</title>
      <link>https://gaoshanwomeng.github.io/post/js-iife%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-iife%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 场景 下面这个面试题你大概率遇到过： 1 2 3 4 5 for (var i = 0; i &amp;lt; 5; i++) { setTimeout(() =&amp;gt; { console.log(i); }, 10); } 这里var会声明一个全局变量i。函数会在10秒后异步执行，当函数在执行时，根据作用域链会在全局变量对象中进行查找，而此时</description>
    </item>
    
    <item>
      <title>浏览器 从浏览器多进程到js单线程</title>
      <link>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%B0js%E5%8D%95%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%B0js%E5%8D%95%E7%BA%BF%E7%A8%8B/</guid>
      <description>windows打开任务管理器，可以看到后台进程列表。可以看到每个进程的内存资源信息以及cpu占有率。 所以，应该更容易理解了：进程是cpu资源分配的最小单位（系统会给它分配内存） 最后，再用较为官方的术语</description>
    </item>
    
    <item>
      <title>js webpack简介</title>
      <link>https://gaoshanwomeng.github.io/post/js-webpack%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-webpack%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 为什么使用webpack 1. 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方法： 引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载大量脚本会导致网络瓶颈。 使用一个包</description>
    </item>
    
    <item>
      <title>css vh&amp;vw</title>
      <link>https://gaoshanwomeng.github.io/post/css-vhvw/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/css-vhvw/</guid>
      <description>1. vw vh的介绍 vw,vh是css3中给我们提供的新的单位，他们是相对于viewport视窗的宽高进行计算的单位。说白了，就是相对于浏览器的窗口的大小。 vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin</description>
    </item>
    
    <item>
      <title>js 正则表达式</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的&amp;quot;hello&amp;quot;这个子串。 1 2 var regex = /hello/; console.log( regex.test(&amp;#34;hello&amp;#34;) ); 正则表达式之所以强大，是因为其能实现模糊匹配。 而</description>
    </item>
    
    <item>
      <title>ssr&amp;csr</title>
      <link>https://gaoshanwomeng.github.io/post/ssrcsr/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/ssrcsr/</guid>
      <description>1. SSR和CSR的概念 SSR(Server Side Rendering)： SSR是传统的渲染方式，由服务端把渲染好的完整的页面发送给客户端。客户端拿到的是完整的页面，可以直接展示。前后端分离之前很长的一段时间里都是以服务端渲染</description>
    </item>
    
    <item>
      <title>ajax 预检请求</title>
      <link>https://gaoshanwomeng.github.io/post/ajax-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/ajax-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82/</guid>
      <description>1.什么是预检请求 定义：预检请求（Preflighted requests ）是浏览器发起跨域请求时，通过OPTIONS方法询问服务器对跨域请求的支持情况（支持的包含请求方法、请求头、数据类型）。 2.什么时候会触发预检</description>
    </item>
    
    <item>
      <title>浏览器 localStorage&amp;sessionStorage&amp;cookie</title>
      <link>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-localstoragesessionstoragecookie/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-localstoragesessionstoragecookie/</guid>
      <description>1. 基本概念 Cookie Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身</description>
    </item>
    
  </channel>
</rss>
