<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>js on TomtomYoung Blog</title>
    <link>https://tomtomyoung.top/tags/js/</link>
    <description>Recent content in js on TomtomYoung Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 07 Sep 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tomtomyoung.top/tags/js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>js Class详解</title>
      <link>https://tomtomyoung.top/post/js-class%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-class%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_Class 1. 声明类 1class Rectangle { 2 constructor(height, width) { 3 this.height = height; 4 this.width = width; 5 } 6} 函数声明和类声明之间的一个重要区别在于，函数声明会提升，类声明不会。你首先需要声明你的类，然后再访问它，否则类似以下的代码将抛出ReferenceE</description>
    </item>
    
    <item>
      <title>js Array详解</title>
      <link>https://tomtomyoung.top/post/js-array%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-array%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_Array Array是一个构造函数，是用于构造数组的全局对象。 1. 构造 Array 实例 1[element0, element1, ..., elementN] 2new Array(element0, element1, ..., elementN) 3new Array(arrayLength) 2. 访问数组 1var arr = [&amp;#39;this is the first element&amp;#39;, &amp;#39;this is the second element&amp;#39;, &amp;#39;this is the last element&amp;#39;]; 2console.log(arr[0]); // 打印 &amp;#39;this is the first element&amp;#39; 3console.log(arr[1]); // 打印 &amp;#39;this is the second element&amp;#39; 4console.log(arr[arr.length - 1]); // 打印 &amp;#39;this is the last element&amp;#39; 3.</description>
    </item>
    
    <item>
      <title>js Object与Function详解</title>
      <link>https://tomtomyoung.top/post/js-object%E4%B8%8Efunction%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-object%E4%B8%8Efunction%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_Object MDN_Function 1. Object 在JavaScript中，几乎所有的对象都是Object类型的实例，它们都会从Object.prototype继承属性和方法。Object 构造函数为给定值创建一个对象包装器。Object</description>
    </item>
    
    <item>
      <title>js 类与继承详解</title>
      <link>https://tomtomyoung.top/post/js-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_JavaScript 中的继承 js继承的几种方式 Javascript继承机制的设计思想 Javascript – How Prototypal Inheritance really works javascript 中实现继承的六种方式 ES6里Class的Extends继承原理 有些人认为JavaScript并不是真正的面向对象</description>
    </item>
    
    <item>
      <title>js new详解</title>
      <link>https://tomtomyoung.top/post/js-new%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-new%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_new js中关键字new的原理（含实现代码） 1. new new会实例化类的实例对象，或者说，使用构造函数，构造一个我们想要的对象。 关于类的定义有两种，使用构造函数定义的类，使用Class关键字定义的类。 1. 构</description>
    </item>
    
    <item>
      <title>js 原型与原型链详解</title>
      <link>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： js对象(一)——创建对象 js对象（二）—— 函数与对象的关系（认识原型链） 一张图搞定JS原型&amp;amp;原型链 js的初学者一般很难理解原型和原型链的概念，但原型和原型链又是js中最重要的点之一，关</description>
    </item>
    
    <item>
      <title>js ES6_module详解</title>
      <link>https://tomtomyoung.top/post/js-es6_module%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-es6_module%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： ES6 module 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的im</description>
    </item>
    
    <item>
      <title>js this详解</title>
      <link>https://tomtomyoung.top/post/js-this%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-this%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_this JavaScript 的 this 原理 彻底理解js中this的指向，不必硬背。 1. 定义this 与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。 在绝大多数情况下，函数的调用</description>
    </item>
    
    <item>
      <title>js umd详解</title>
      <link>https://tomtomyoung.top/post/js-umd%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-umd%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： umd.js 可能是最详细的UMD模块入门指南 1. UMD 因为有像CommonJS、AMD、CMD等不同的规范，导致了js实现模块化有很多方式，那有没有一种方式可以屏蔽掉这种不同，让我们不去思考使用什么模块化规范，</description>
    </item>
    
    <item>
      <title>js 模块化详解</title>
      <link>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 前端模块化：CommonJS,AMD,CMD,ES6 wikipedia_CommonJS 深入浅出Node.js 前端科普系列-CommonJS：不是前端却革命了前端 从 CommonJS 到 Sea.js CommonJS wiki mozillaWiki_ServerJS 《编程时间简史系列》JavaScript 模块化的历史</description>
    </item>
    
    <item>
      <title>js 闭包详解</title>
      <link>https://tomtomyoung.top/post/js-%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_闭包 你不懂JS：作用域与闭包 学习Javascript闭包（Closure） 在 JavaScript 中闭包无所不在，你必须识别并接纳它。 闭包是词法作用域导致的结果。闭包在你的代码中一直在被创建和使用，你在毫无</description>
    </item>
    
    <item>
      <title>js let&amp;const与块级作用域</title>
      <link>https://tomtomyoung.top/post/js-letconst%E4%B8%8E%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-letconst%E4%B8%8E%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>参考： MDN_let 为什么在 JavaScript 中为块范围变量声明选择名称“let”？ let深入理解&amp;mdash;let存在变量提升吗？ 我用了两个月的时间才理解 let JS变量封禁大法：薛定谔的X let 声明会提升（hoist）吗？ 1. 作用域对</description>
    </item>
    
    <item>
      <title>js 作用域&amp;作用域链</title>
      <link>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</guid>
      <description>参考： MDN Scope 深入理解javascript作用域系列第一篇——内部原理 深入理解javascript作用域系列第二篇——词法作用域和动态作用域 你不懂JS：作用域与闭包 let, const和块级作用域 1. 作用域 第一种说</description>
    </item>
    
    <item>
      <title>js 代码解释执行详解</title>
      <link>https://tomtomyoung.top/post/js-%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 编译语言和解释语言的区别 编译器与解释器 JavaScript的工作原理：解析、抽象语法树（AST）+ 提升编译速度5个技巧 IBM compiled-versus-interpreted-languages JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的 WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理 JS</description>
    </item>
    
    <item>
      <title>js Symbol详解</title>
      <link>https://tomtomyoung.top/post/js-symbol%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-symbol%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 为什么需要 Symbol 对象在 JavaScript 语言中扮演重要角色，它们的使用无处不在。对象通常用作键/值对的集合，然而，以这种方式使用它们有一个很大的限制: 在 symbol 出现之前，对象键只能是字符串，如果试图使用非字符串值作为对象的键</description>
    </item>
    
    <item>
      <title>js Set详解</title>
      <link>https://tomtomyoung.top/post/js-set%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-set%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Set 定义 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 2. Set 中的特殊值 Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的</description>
    </item>
    
    <item>
      <title>js 手写Promise</title>
      <link>https://tomtomyoung.top/post/js-%E6%89%8B%E5%86%99promise/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%89%8B%E5%86%99promise/</guid>
      <description>1. 简易版Promise 1. 实现executor 比如我们实例化一个Promise对象时，会这样写： 1let p1 = new Promise((resolve, reject) =&amp;gt; { 2 resolve(12345); 3}) 这里要注意的是： constructor接收一个函数作为参数； 这个传入的函数会在实例化</description>
    </item>
    
    <item>
      <title>js Map详解</title>
      <link>https://tomtomyoung.top/post/js-map%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-map%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Map 定义 MDN map Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。 map和object的对比 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（</description>
    </item>
    
    <item>
      <title>js Promise详解</title>
      <link>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Promise 定义 promise A+ A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled. promise表示异步操作的最终结果。与promise交互的主要方式是通过它的then方</description>
    </item>
    
    <item>
      <title>js setTimeout&amp;setInterval</title>
      <link>https://tomtomyoung.top/post/js-settimeoutsetinterval/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-settimeoutsetinterval/</guid>
      <description>1. setTimeout setTimeout的在一段时间之后，执行指定的一段函数 （仅执行一次） 可以理解为指定延迟后执行函数 2. setInterval setInterval是循环执行函数，每隔一段时间就执行一次指定的函数（执行N次） 可以理解为指</description>
    </item>
    
    <item>
      <title>js 事件循环与异步并发</title>
      <link>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</guid>
      <description>参考： The JavaScript Event Loop: Explained ES2015(ES6) MDN_并发模型与事件循环 MDN_深入：微任务和 JavaScript 运行时环境 MDN_在 JavaScript 中通过 queueMicrotask() 使用微任务 Node.js_event_loop WHATWG规范_event_loop JavaScript Info_event-loop 宏任务和微任务到底是什么？ JavaScript 运行机制详解：再谈E</description>
    </item>
    
    <item>
      <title>js IIFE简介</title>
      <link>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 场景 下面这个面试题你大概率遇到过： 1for (var i = 0; i &amp;lt; 5; i++) { 2 setTimeout(() =&amp;gt; { 3 console.log(i); 4 }, 10); 5} 这里var会声明一个全局变量i。函数会在10毫秒后异步执行，当函数在执行时，根据作用域链会在全局变量对象中进行查找，而此时循</description>
    </item>
    
    <item>
      <title>js webpack简介</title>
      <link>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 为什么使用webpack 1. 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方法： 引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载大量脚本会导致网络瓶颈。 使用一个包</description>
    </item>
    
    <item>
      <title>cross origin requests are only supported for protocol schemes填坑</title>
      <link>https://tomtomyoung.top/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</guid>
      <description>今天在写了一个简单的H5页面，项目结构如下图所示： 然后在运行的时候突然报错 Access to script at ‘file:///Volumes/PERSON/font_end/h5xuexi/h5-learning3/vue_n</description>
    </item>
    
    <item>
      <title>js 循环遍历详解</title>
      <link>https://tomtomyoung.top/post/js-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考：</description>
    </item>
    
    <item>
      <title>js 正则表达式</title>
      <link>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的&amp;quot;hello&amp;quot;这个子串。 1var regex = /hello/; 2console.log( regex.test(&amp;#34;hello&amp;#34;) ); 正则表达式之所以强大，是因为其能实现模糊匹配。 而模糊</description>
    </item>
    
    <item>
      <title>ssr&amp;csr</title>
      <link>https://tomtomyoung.top/post/ssrcsr/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ssrcsr/</guid>
      <description>1. SSR和CSR的概念 SSR(Server Side Rendering)： SSR是传统的渲染方式，由服务端把渲染好的完整的页面发送给客户端。客户端拿到的是完整的页面，可以直接展示。前后端分离之前很长的一段时间里都是以服务端渲染</description>
    </item>
    
    <item>
      <title>ecmascript&amp;javascript</title>
      <link>https://tomtomyoung.top/post/ecmascriptjavascript/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ecmascriptjavascript/</guid>
      <description>1. ECMAScript的简介 ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这</description>
    </item>
    
  </channel>
</rss>