<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>js on TomtomYoung Blog</title>
    <link>https://gaoshanwomeng.github.io/tags/js/</link>
    <description>Recent content in js on TomtomYoung Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 11 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://gaoshanwomeng.github.io/tags/js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>js 迭代器与生成器</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>什么是生成器 生成器其实就是一个特殊的函数，是异步编程的一种解决方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //函数代码的分隔符 function * gen(){ console.log(111); yield &amp;#39;一只没有耳朵&amp;#39;; console.log(222); yield &amp;#39;一只没有尾部</description>
    </item>
    
    <item>
      <title>js 作用域&amp;作用域链&amp;闭包</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</guid>
      <description>hhh</description>
    </item>
    
    <item>
      <title>js 箭头函数详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 为什么叫Arrow Function？因为它的定义用的就是一个箭头： 1 x =&amp;gt; x * x 上面的箭头函数相当于： 1 2 3 function (x) { return x * x; } 箭头函数</description>
    </item>
    
    <item>
      <title>js 手写promise</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E6%89%8B%E5%86%99promise/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E6%89%8B%E5%86%99promise/</guid>
      <description>1. 简易版Promise 1. 实现executor 比如我们实例化一个Promise对象时，会这样写： 1 2 3 let p1 = new Promise((resolve, reject) =&amp;gt; { resolve(12345); }) 这里要注意的是： constructor接收一个函数作为参数； 这个传入的函数会在实</description>
    </item>
    
    <item>
      <title>浏览器 本地存储详解</title>
      <link>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 基本概念 Cookie Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身</description>
    </item>
    
    <item>
      <title>js jsonp详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-jsonp%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-jsonp%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 同源策略和域 关于什么是浏览器的同源策略，什么是域，可以查看本站另一篇文章：浏览器 同源策略详解</description>
    </item>
    
    <item>
      <title>js map详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-map%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-map%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. map 定义 MDN map Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。 map和object的对比 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（</description>
    </item>
    
    <item>
      <title>js 模块化详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 发展历程 在本站另一篇博客：webpack简介的第一个章节：为什么使用webpack中，我们介绍了js代码编写的不同阶段： 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方</description>
    </item>
    
    <item>
      <title>js promise详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-promise%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-promise%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Promise 定义 promise A+ A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled. promise表示异步操作的最终结果。与promise交互的主要方式是通过它的then方</description>
    </item>
    
    <item>
      <title>js 原型&amp;原型链&amp;继承</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</guid>
      <description>1. prototype 每个函数都有一个 prototype 属性 每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&amp;quot;继承&amp;quot;属性。 1 2 3 4 5</description>
    </item>
    
    <item>
      <title>js setTimeout&amp;setInterval</title>
      <link>https://gaoshanwomeng.github.io/post/js-settimeoutsetinterval/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-settimeoutsetinterval/</guid>
      <description>1. setTimeout setTimeout的在一段时间之后，执行指定的一段函数 （仅执行一次） 可以理解为指定延迟后执行函数 2. setInterval setInterval是循环执行函数，每隔一段时间就执行一次指定的函数（执行N次） 可以理解为指</description>
    </item>
    
    <item>
      <title>js 事件循环与异步并发</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</guid>
      <description>1. JS事件 The event loop is the secret behind JavaScript’s asynchronous programming. JS executes all operations on a single thread, but using a few smart data structures, gives us the illusion of multi-threading. The asynchronous behavior is not part of the JavaScript language itself, rather it is built on top of the core JavaScript language in the browser (or the programming environment) and accessed through the browser APIs. 事件循环是JavaScript异步编</description>
    </item>
    
    <item>
      <title>js IIFE简介</title>
      <link>https://gaoshanwomeng.github.io/post/js-iife%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-iife%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 场景 下面这个面试题你大概率遇到过： 1 2 3 4 5 for (var i = 0; i &amp;lt; 5; i++) { setTimeout(() =&amp;gt; { console.log(i); }, 10); } 这里var会声明一个全局变量i。函数会在10秒后异步执行，当函数在执行时，根据作用域链会在全局变量对象中进行查找，而此时</description>
    </item>
    
    <item>
      <title>js webpack简介</title>
      <link>https://gaoshanwomeng.github.io/post/js-webpack%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-webpack%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 为什么使用webpack 1. 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方法： 引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载大量脚本会导致网络瓶颈。 使用一个包</description>
    </item>
    
    <item>
      <title>面试题——JS</title>
      <link>https://gaoshanwomeng.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%98js/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%98js/</guid>
      <description>1. JS基本数据类型 1.1 基本类型 1.2 引用类型 1.3 数据类型的判断 1.4 数据类型的转换 2. 数组的常用方法 2.1 改变原数组的方法 2.2 不改变原数组的方法 2.3 数组的遍历 3. 字符串的常用方法 4. 对象的常用方法 5. Math方法和Date方法 6.</description>
    </item>
    
    <item>
      <title>js 函数柯里化与高阶函数</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</guid>
      <description>1. 函数柯里化 函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 2. 高阶函数定义 高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。 若A函数，</description>
    </item>
    
    <item>
      <title>js 数据结构</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>数据结构是计算机存储、组织数据的方式,算法是系统描述解决问题的策略。了解基本的数据结构和算法可以提高代码的性能和质量。 1. 栈 栈的特点：先进后出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30</description>
    </item>
    
    <item>
      <title>cross origin requests are only supported for protocol schemes填坑</title>
      <link>https://gaoshanwomeng.github.io/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</guid>
      <description>今天在写了一个简单的H5页面，项目结构如下图所示： 然后在运行的时候突然报错 Access to script at ‘file:///Volumes/PERSON/font_end/h5xuexi/h5-learning3/vue_n</description>
    </item>
    
    <item>
      <title>js 循环遍历详解</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. for循环 javascript中的for循环选择多种多样，可你知道其中的差别在哪里吗？什么时候又该用哪种循环才是最佳策略？ 1.1 for 1 2 3 4 //20年前的写法let len = myArray.Length for (let index = 0; index &amp;lt; len; index++) { console.log(myArray[index]) } 1.2 forEach 1 2 3</description>
    </item>
    
    <item>
      <title>js 正则表达式</title>
      <link>https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的&amp;quot;hello&amp;quot;这个子串。 1 2 var regex = /hello/; console.log( regex.test(&amp;#34;hello&amp;#34;) ); 正则表达式之所以强大，是因为其能实现模糊匹配。 而</description>
    </item>
    
    <item>
      <title>ssr&amp;csr</title>
      <link>https://gaoshanwomeng.github.io/post/ssrcsr/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/ssrcsr/</guid>
      <description>1. SSR和CSR的概念 SSR(Server Side Rendering)： SSR是传统的渲染方式，由服务端把渲染好的完整的页面发送给客户端。客户端拿到的是完整的页面，可以直接展示。前后端分离之前很长的一段时间里都是以服务端渲染</description>
    </item>
    
    <item>
      <title>ecmascript&amp;javascript</title>
      <link>https://gaoshanwomeng.github.io/post/ecmascriptjavascript/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/ecmascriptjavascript/</guid>
      <description>1. ECMAScript的简介 ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这</description>
    </item>
    
    <item>
      <title>js let&amp;const&amp;var</title>
      <link>https://gaoshanwomeng.github.io/post/js-letconstvar/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://gaoshanwomeng.github.io/post/js-letconstvar/</guid>
      <description>1. let，const没有变量提升 首先让我们了解下JavaScript变量赋值的大概过程： 1 2 3 4 5 6 7 8 9 10 11 12 ECStack EC(G) VO(G) 声明提升(函数+变量) 1. 函数声明提升 2. 变量声明提升 变量赋值： 1. 创建变量 2. 创建值(对</description>
    </item>
    
  </channel>
</rss>
