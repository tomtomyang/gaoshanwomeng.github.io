<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>js on TomtomYoung Blog</title>
    <link>https://tomtomyoung.top/tags/js/</link>
    <description>Recent content in js on TomtomYoung Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 20 Aug 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tomtomyoung.top/tags/js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>js 扩展运算符和rest参数</title>
      <link>https://tomtomyoung.top/post/js-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E5%8F%82%E6%95%B0/</link>
      <pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E5%8F%82%E6%95%B0/</guid>
      <description>『&amp;hellip;』 扩展运算符能将『数组』转换为逗号分隔的『参数序列』 1//声明一个数组 ... 2const tfboys = [&amp;#39;易烊千玺&amp;#39;,&amp;#39;王源&amp;#39;,&amp;#39;王俊凯&amp;#39;]; 3// =&amp;gt; &amp;#39;易</description>
    </item>
    
    <item>
      <title>js 作用域&amp;作用域链&amp;闭包</title>
      <link>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E9%97%AD%E5%8C%85/</link>
      <pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E9%97%AD%E5%8C%85/</guid>
      <description>参考： MDN Scope 深入理解javascript作用域系列第一篇——内部原理 深入理解javascript作用域系列第二篇——词法作用域和动态作用域 你不懂JS：作用域与闭包 1. 作用域 第一种说法： javascript</description>
    </item>
    
    <item>
      <title>js array详解</title>
      <link>https://tomtomyoung.top/post/js-array%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-array%E8%AF%A6%E8%A7%A3/</guid>
      <description>创建一个数组 字面量方式 1var a = [3, 11, 8]; 构造器 1// 创建一个指定大小的数组 2let 数组名称 = new Array(数组长度); 3// 创建一个空数组 4let 数组名称 = new Array(); 5// 创建一个给定数据的数组 6let 数组名称 = new Array(data1, data2, data3...); ES6 Array.of() 定义：返回由所有参</description>
    </item>
    
    <item>
      <title>js string详解</title>
      <link>https://tomtomyoung.top/post/js-string%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-string%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 字符串长度 length 属性返回字符串的长度： 实例 1var txt = &amp;#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;#34;; 2var sln = txt.length; 2. 查找字符串中的字符串 indexOf() 方法返回字符串中指定文本首次出现的索引（位置）： 实例 1var str = &amp;#34;The full name of China is the People&amp;#39;s Republic of China.&amp;#34;; 2var pos = str.indexOf(&amp;#34;China&amp;#34;); JavaScript 从零计算位置。 0 是字符串中的第</description>
    </item>
    
    <item>
      <title>js 代码解释执行详解</title>
      <link>https://tomtomyoung.top/post/js-%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 编译语言和解释语言的区别 编译器与解释器 JavaScript的工作原理：解析、抽象语法树（AST）+ 提升编译速度5个技巧 IBM compiled-versus-interpreted-languages JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的 WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理 JS</description>
    </item>
    
    <item>
      <title>js symbol详解</title>
      <link>https://tomtomyoung.top/post/js-symbol%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-symbol%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 为什么会出现Symbol 对象在 JavaScript 语言中扮演重要角色，它们的使用无处不在。对象通常用作键/值对的集合，然而，以这种方式使用它们有一个很大的限制: 在 symbol 出现之前，对象键只能是字符串，如果试图使用非字符串值</description>
    </item>
    
    <item>
      <title>js set详解</title>
      <link>https://tomtomyoung.top/post/js-set%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-set%E8%AF%A6%E8%A7%A3/</guid>
      <description>Set 对象 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 Set 中的特殊值 Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的，所</description>
    </item>
    
    <item>
      <title>js 迭代器与生成器</title>
      <link>https://tomtomyoung.top/post/js-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>什么是生成器 生成器其实就是一个特殊的函数，是异步编程的一种解决方案 1//函数代码的分隔符 2function * gen(){ 3 console.log(111); 4 yield &amp;#39;一只没有耳朵&amp;#39;; 5 console.log(222); 6 yield &amp;#39;一只没有尾部&amp;#39;; 7 console.log(333); 8 yield &amp;#39;真奇</description>
    </item>
    
    <item>
      <title>js 箭头函数详解</title>
      <link>https://tomtomyoung.top/post/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 为什么叫Arrow Function？因为它的定义用的就是一个箭头： 1x =&amp;gt; x * x 上面的箭头函数相当于： 1function (x) { 2 return x * x; 3} 箭头函数相当于</description>
    </item>
    
    <item>
      <title>js 手写promise</title>
      <link>https://tomtomyoung.top/post/js-%E6%89%8B%E5%86%99promise/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%89%8B%E5%86%99promise/</guid>
      <description>1. 简易版Promise 1. 实现executor 比如我们实例化一个Promise对象时，会这样写： 1let p1 = new Promise((resolve, reject) =&amp;gt; { 2 resolve(12345); 3}) 这里要注意的是： constructor接收一个函数作为参数； 这个传入的函数会在实例化</description>
    </item>
    
    <item>
      <title>js jsonp详解</title>
      <link>https://tomtomyoung.top/post/js-jsonp%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-jsonp%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 同源策略和域 关于什么是浏览器的同源策略，什么是域，可以查看本站另一篇文章：浏览器 同源策略详解</description>
    </item>
    
    <item>
      <title>js map详解</title>
      <link>https://tomtomyoung.top/post/js-map%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-map%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. map 定义 MDN map Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。 map和object的对比 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（</description>
    </item>
    
    <item>
      <title>js 模块化详解</title>
      <link>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 发展历程 在本站另一篇博客：webpack简介的第一个章节：为什么使用webpack中，我们介绍了js代码编写的不同阶段： 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方</description>
    </item>
    
    <item>
      <title>js promise详解</title>
      <link>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Promise 定义 promise A+ A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled. promise表示异步操作的最终结果。与promise交互的主要方式是通过它的then方</description>
    </item>
    
    <item>
      <title>js 原型&amp;原型链&amp;继承</title>
      <link>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</guid>
      <description>1. prototype 每个函数都有一个 prototype 属性 每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&amp;quot;继承&amp;quot;属性。 1function Person() { 2 3}</description>
    </item>
    
    <item>
      <title>js setTimeout&amp;setInterval</title>
      <link>https://tomtomyoung.top/post/js-settimeoutsetinterval/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-settimeoutsetinterval/</guid>
      <description>1. setTimeout setTimeout的在一段时间之后，执行指定的一段函数 （仅执行一次） 可以理解为指定延迟后执行函数 2. setInterval setInterval是循环执行函数，每隔一段时间就执行一次指定的函数（执行N次） 可以理解为指</description>
    </item>
    
    <item>
      <title>js 事件循环与异步并发</title>
      <link>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</guid>
      <description>参考： The JavaScript Event Loop: Explained ES2015(ES6) MDN_并发模型与事件循环 MDN_深入：微任务和 JavaScript 运行时环境 MDN_在 JavaScript 中通过 queueMicrotask() 使用微任务 Node.js_event_loop WHATWG规范_event_loop JavaScript Info_event-loop 宏任务和微任务到底是什么？ JavaScript 运行机制详解：再谈E</description>
    </item>
    
    <item>
      <title>js IIFE简介</title>
      <link>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 场景 下面这个面试题你大概率遇到过： 1for (var i = 0; i &amp;lt; 5; i++) { 2 setTimeout(() =&amp;gt; { 3 console.log(i); 4 }, 10); 5} 这里var会声明一个全局变量i。函数会在10毫秒后异步执行，当函数在执行时，根据作用域链会在全局变量对象中进行查找，而此时循</description>
    </item>
    
    <item>
      <title>js webpack简介</title>
      <link>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 为什么使用webpack 1. 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方法： 引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载大量脚本会导致网络瓶颈。 使用一个包</description>
    </item>
    
    <item>
      <title>面试题——JS</title>
      <link>https://tomtomyoung.top/post/%E9%9D%A2%E8%AF%95%E9%A2%98js/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E9%9D%A2%E8%AF%95%E9%A2%98js/</guid>
      <description>1. JS基本数据类型 1.1 基本类型 1.2 引用类型 1.3 数据类型的判断 1.4 数据类型的转换 2. 数组的常用方法 2.1 改变原数组的方法 2.2 不改变原数组的方法 2.3 数组的遍历 3. 字符串的常用方法 4. 对象的常用方法 5. Math方法和Date方法 6.</description>
    </item>
    
    <item>
      <title>js 函数柯里化与高阶函数</title>
      <link>https://tomtomyoung.top/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E4%B8%8E%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</guid>
      <description>1. 函数柯里化 函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 2. 高阶函数 2.1 定义 高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。 若A函数</description>
    </item>
    
    <item>
      <title>js 数据结构</title>
      <link>https://tomtomyoung.top/post/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>数据结构是计算机存储、组织数据的方式,算法是系统描述解决问题的策略。了解基本的数据结构和算法可以提高代码的性能和质量。 1. 栈 栈的特点：先进后出 1class Stack { 2 constructor() { 3 this.items = []; 4 } 5 6 // 入栈 7 push(element) { 8 this.items.push(element); 9 } 10 11 // 出栈 12</description>
    </item>
    
    <item>
      <title>cross origin requests are only supported for protocol schemes填坑</title>
      <link>https://tomtomyoung.top/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</guid>
      <description>今天在写了一个简单的H5页面，项目结构如下图所示： 然后在运行的时候突然报错 Access to script at ‘file:///Volumes/PERSON/font_end/h5xuexi/h5-learning3/vue_n</description>
    </item>
    
    <item>
      <title>js 循环遍历详解</title>
      <link>https://tomtomyoung.top/post/js-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. for循环 javascript中的for循环选择多种多样，可你知道其中的差别在哪里吗？什么时候又该用哪种循环才是最佳策略？ 1.1 for 1//20年前的写法let len = myArray.Length 2for (let index = 0; index &amp;lt; len; index++) { 3 console.log(myArray[index]) 4} 1.2 forEach 1//ES</description>
    </item>
    
    <item>
      <title>js 正则表达式</title>
      <link>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的&amp;quot;hello&amp;quot;这个子串。 1var regex = /hello/; 2console.log( regex.test(&amp;#34;hello&amp;#34;) ); 正则表达式之所以强大，是因为其能实现模糊匹配。 而模糊</description>
    </item>
    
    <item>
      <title>ssr&amp;csr</title>
      <link>https://tomtomyoung.top/post/ssrcsr/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ssrcsr/</guid>
      <description>1. SSR和CSR的概念 SSR(Server Side Rendering)： SSR是传统的渲染方式，由服务端把渲染好的完整的页面发送给客户端。客户端拿到的是完整的页面，可以直接展示。前后端分离之前很长的一段时间里都是以服务端渲染</description>
    </item>
    
    <item>
      <title>ecmascript&amp;javascript</title>
      <link>https://tomtomyoung.top/post/ecmascriptjavascript/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ecmascriptjavascript/</guid>
      <description>1. ECMAScript的简介 ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这</description>
    </item>
    
    <item>
      <title>js let&amp;const&amp;var</title>
      <link>https://tomtomyoung.top/post/js-letconstvar/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-letconstvar/</guid>
      <description>1. let，const没有变量提升 首先让我们了解下JavaScript变量赋值的大概过程： 1ECStack 2 EC(G) 3 VO(G) 4 声明提升(函数+变量) 5 1. 函数声明提升 6 2. 变量声明提升 7 变量赋值： 8 1. 创建变量 9 2. 创建值(对象会开辟</description>
    </item>
    
  </channel>
</rss>