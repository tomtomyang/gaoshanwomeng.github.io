<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>js on TomtomYoung Blog 🧐</title>
    <link>https://tomtomyoung.top/tags/js/</link>
    <description>Recent content in js on TomtomYoung Blog 🧐</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 09 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://tomtomyoung.top/tags/js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E5%85%B3%E4%BA%8Ejs%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E5%85%B3%E4%BA%8Ejs%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%A0%94%E7%A9%B6/</guid>
      <description>参考： 前端现代包管理器的进化史 【前端工程化】篇二 白璧微瑕：包管理器 前端包管理器争端，只不过是构建工具的牙缝菜 新一代包管理工具 pnpm 1. 包&amp;amp;包管理器 在很久很久以前，前端叫做“切图仔”，那时前端的工作非</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-async%E4%B8%8Eawait%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 24 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-async%E4%B8%8Eawait%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： async 和 await:让异步编程更简单 1. async 首先，我们使用 async 关键字，把它放在函数声明之前，使其成为 async function 。异步函数是一个知道怎样使用 await 关键字调用异步代码的函数。 2. await 3. generator</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-generator%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 24 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-generator%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_Generator Generator 函数的含义与用法 1. 异步编程 异步编程对 JavaScript 语言太重要。JavaScript 只有单线程，如果没有异步编程，根本没法用，非卡死不可。 以前，异步编程的方法，大概有 下面四种 。 回调函数 事件监听 发布/订阅 Promise</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-class%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-class%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_Class 1. 声明类 1class Rectangle { 2 constructor(height, width) { 3 this.height = height; 4 this.width = width; 5 } 6} 函数声明和类声明之间的一个重要区别在于，函数声明会提升，类声明不会。你首先需要声明你的类，然后再访问它，否则类似以下的代码将抛出 ReferenceError ： 1let p = new Rectangle(); // ReferenceError 2</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-array%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-array%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_Array Array 是一个构造函数，是用于构造数组的全局对象。 1. 构造 Array 实例 1[element0, element1, ..., elementN] 2new Array(element0, element1, ..., elementN) 3new Array(arrayLength) 2. 访问数组 1var arr = [&amp;#39;this is the first element&amp;#39;, &amp;#39;this is the second element&amp;#39;, &amp;#39;this is the last element&amp;#39;]; 2console.log(arr[0]); // 打印 &amp;#39;this is the first element&amp;#39; 3console.log(arr[1]); // 打印 &amp;#39;this is the second element&amp;#39; 4console.log(arr[arr.length - 1]); // 打印 &amp;#39;this is the last element&amp;#39; 3. Array 数组构</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</link>
      <pubDate>Fri, 03 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</guid>
      <description>1. 高阶函数 1. 定义 高阶函数：如果一个函数符合下面 2 个规范中的任何一个，那该函数就是高阶函数。 若 A 函数，接收的参数是一个函数，那么 A 就可以称之为高阶函数。 若 A 函数，调用的返回值依然是一个函数，那么 A 就可以</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>参考： MDN JavaScript 数据类型和数据结构 1. 数据类型 最新的 ECMAScript 标准定义了 8 种数据类型: 6 种原始类型，可以使用 typeof 运算符检查： undefined ：typeof instance === &amp;quot;undefined&amp;quot; Boolean ：typeof instance === &amp;quot;boolean&amp;quot; Number ：typeof instance === &amp;quot;number&amp;quot; String ：typeof instance === &amp;quot;string BigInt ：t</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-object%E4%B8%8Efunction%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-object%E4%B8%8Efunction%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_Object MDN_Function 1. Object 在 JavaScript 中，几乎所有的对象都是 Object 类型的实例，它们都会从 Object.prototype 继承属性和方法。Object 构造函数为给定值创建一个对象包装器。Object 构造函数，会根据给定的参数创建对象，具体有以下情况： 如果给</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_JavaScript 中的继承 js 继承的几种方式 Javascript 继承机制的设计思想 Javascript – How Prototypal Inheritance really works javascript 中实现继承的六种方式 ES6 里 Class 的 Extends 继承原理 有些人认为 JavaScript 并不是真正的面向对象语言，在经典的面向对象语言中，您可能倾向于定义类对象，然后您可</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-new%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-new%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_new js 中关键字 new 的原理（含实现代码） 1. new new 会实例化类的实例对象，或者说，使用构造函数，构造一个我们想要的对象。 关于类的定义有两种，使用构造函数定义的类，使用 Class 关键字定义的类。 1. 构造函数定义类 在 MDN 中</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： js 对象(一)——创建对象 js 对象（二）—— 函数与对象的关系（认识原型链） 一张图搞定 JS 原型&amp;amp;原型链 js 的初学者一般很难理解原型和原型链的概念，但原型和原型链又是 js 中最重要的点之一，关系到对 js 所</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-es6_module%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-es6_module%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： ES6 module 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 im</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-this%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-this%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_this JavaScript 的 this 原理 彻底理解 js 中 this 的指向，不必硬背。 1. 定义 this 与其他语言相比，函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在 严格模式 和非严格模式之间也会有一些差别。 在绝大多数情况下，函数的调用方式决定了 this 的</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-umd%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-umd%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： umd.js 可能是最详细的 UMD 模块入门指南 1. UMD 因为有像 CommonJS、AMD、CMD 等不同的规范，导致了 js 实现模块化有很多方式，那有没有一种方式可以屏蔽掉这种不同，让我们不去思考使用什么模块化规范，专心的</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</guid>
      <description>解构赋值 什么是解构赋值？ 在语法上，就是赋值的作用，解构为（左边一种解构。右边一种解构，左右一一对应进入赋值） 解构赋值的分类。 左右为数组即为数组解构赋值； 左右为对象即为对象解构赋值； 左边是数组，右边是字</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 前端模块化：CommonJS,AMD,CMD,ES6 wikipedia_CommonJS 深入浅出 Node.js 前端科普系列-CommonJS：不是前端却革命了前端 从 CommonJS 到 Sea.js CommonJS wiki mozillaWiki_ServerJS 《编程时间简史系列》JavaScript 模块化的历史进程 Node.js_CommonJS modules RequireJS 和</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： MDN_闭包 你不懂 JS：作用域与闭包 学习 Javascript 闭包（Closure） 在 JavaScript 中闭包无所不在，你必须识别并接纳它。 闭包是词法作用域导致的结果。闭包在你的代码中一直在被创建和使用，你在毫无意识的状态下就使用</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-letconst%E4%B8%8E%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-letconst%E4%B8%8E%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>参考： MDN_let 为什么在 JavaScript 中为块范围变量声明选择名称“let”？ let 深入理解&amp;mdash;let 存在变量提升吗？ 我用了两个月的时间才理解 let JS 变量封禁大法：薛定谔的 X let 声明会提升（hoist）吗？ 1. 作用域对 var 的处</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</link>
      <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</guid>
      <description>参考： MDN Scope 深入理解 javascript 作用域系列第一篇——内部原理 深入理解 javascript 作用域系列第二篇——词法作用域和动态作用域 你不懂 JS：作用域与闭包 let, const 和块级作用域 1. 作用域 第一种说法： javascript 拥有一套设计良好的规则来存储变量，并且</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E8%AF%A6%E8%A7%A3/</guid>
      <description>参考： 编译语言和解释语言的区别 编译器与解释器 JavaScript 的工作原理：解析、抽象语法树（AST）+ 提升编译速度 5 个技巧 IBM compiled-versus-interpreted-languages JavaScript 编译 - JIT (just-in-time) compiler 是怎么工作的 WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理 JS - AST 基本概念 JS AST 原</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-symbol%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-symbol%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. 为什么需要 Symbol 对象在 JavaScript 语言中扮演重要角色，它们的使用无处不在。对象通常用作键/值对的集合，然而，以这种方式使用它们有一个很大的限制: 在 symbol 出现之前，对象键只能是字符串，如果试图使用非字符串值作为对象的键</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-set%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-set%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Set 定义 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 2. Set 中的特殊值 Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>什么是生成器 生成器其实就是一个特殊的函数，是异步编程的一种解决方案 1//函数代码的分隔符 2function * gen(){ 3 console.log(111); 4 yield &amp;#39;一只没有耳朵&amp;#39;; 5 console.log(222); 6 yield &amp;#39;一只没有尾部&amp;#39;; 7 console.log(333); 8 yield &amp;#39;真奇</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</guid>
      <description>ES6 标准新增了一种新的函数：Arrow Function（箭头函数）。 1. 定义 为什么叫 Arrow Function？因为它的定义用的就是一个箭头： 1x =&amp;gt; x * x 上面的箭头函数相当于： 1function (x) { 2 return x * x; 3} 箭头函数相当于匿名函</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0promise/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0promise/</guid>
      <description>1. 简易版 Promise 1. 实现 executor 比如我们实例化一个 Promise 对象时，会这样写： 1let p1 = new Promise((resolve, reject) =&amp;gt; { 2 resolve(12345); 3}) 这里要注意的是： constructor 接收一个函数作为参数； 这个传入的函数会在实例化时（执行构造函数时）立即执行； 传入的函数接收两个函数（re</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-map%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-map%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Map 定义 MDN map Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值都可以作为一个键或一个值。 map 和 object 的对比 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-promise%E8%AF%A6%E8%A7%A3/</guid>
      <description>1. Promise 定义 promise A+ A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled. promise 表示异步操作的最终结果。与 promise 交互的主要方式是通过它的 then 方法，该方法注册回调来接收 promise 的最</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-settimeoutsetinterval/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-settimeoutsetinterval/</guid>
      <description>1. setTimeout setTimeout 的在一段时间之后，执行指定的一段函数 （仅执行一次） 可以理解为指定延迟后执行函数 2. setInterval setInterval 是循环执行函数，每隔一段时间就执行一次指定的函数（执行 N 次） 可以理解为指定周期执行函数 3. 两者区别 两个函数的另一</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/</guid>
      <description>参考： The JavaScript Event Loop: Explained ES2015(ES6) MDN_并发模型与事件循环 MDN_深入：微任务和 JavaScript 运行时环境 MDN_在 JavaScript 中通过 queueMicrotask() 使用微任务 Node.js_event_loop WHATWG 规范_event_loop JavaScript Info_event-loop 宏任务和微任务到底是什么？ JavaScript 运行机制详解：再谈 Event Loop 事件循环</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-iife%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 场景 下面这个面试题你大概率遇到过： 1for (var i = 0; i &amp;lt; 5; i++) { 2 setTimeout(() =&amp;gt; { 3 console.log(i); 4 }, 10); 5} 这里 var 会声明一个全局变量 i。函数会在 10 毫秒后异步执行，当函数在执行时，根据作用域链会在全局变量对象中进行查找，而此时循环已经</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-webpack%E7%AE%80%E4%BB%8B/</guid>
      <description>1. 为什么使用 webpack 1. 远古阶段 在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的？ 在浏览器中运行 JavaScript 有两种方法： 引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载大量脚本会导致网络瓶颈。 使用一个包含所有项目代</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/cross-origin-requests-are-only-supported-for-protocol-schemes%E5%A1%AB%E5%9D%91/</guid>
      <description>今天在写了一个简单的 H5 页面，项目结构如下图所示： 然后在运行的时候突然报错 Access to script at ‘file:///Volumes/PERSON/font_end/h5xuexi/h5-learning3/vue_no</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/js-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1 两种模糊匹配 如果正则只有精确匹配是没多大意义的，比如/hello/，也只能匹配字符串中的&amp;quot;hello&amp;quot;这个子串。 1var regex = /hello/; 2console.log( regex.test(&amp;#34;hello&amp;#34;) ); 正则表达式之所以强大，是因为其能实现模糊匹配。 而模糊</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/ssrcsr/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ssrcsr/</guid>
      <description>1. SSR 和 CSR 的概念 SSR(Server Side Rendering)： SSR 是传统的渲染方式，由服务端把渲染好的完整的页面发送给客户端。客户端拿到的是完整的页面，可以直接展示。前后端分离之前很长的一段时间里都是以服务端渲染为主（ASP</description>
    </item>
    
    <item>
      <title></title>
      <link>https://tomtomyoung.top/post/ecmascriptjavascript/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tomtomyoung.top/post/ecmascriptjavascript/</guid>
      <description>1. ECMAScript 的简介 ECMAScript 是一种由 Ecma 国际（前身为欧洲计算机制造商协会,英文名称是 European Computer Manufacturers Association）通过 ECMA-262 标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，所以它可以理</description>
    </item>
    
  </channel>
</rss>
